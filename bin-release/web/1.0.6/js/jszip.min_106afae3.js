"use strict"; var _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t }; !function (t) {
window.JSZip = function () {
  return function t(e, r, n) { function i(s, o) { if (!r[s]) { if (!e[s]) { var d = "function" == typeof require && require; if (!o && d) return d(s, !0); if (a) return a(s, !0); throw Error("Cannot find module '" + s + "'") } o = r[s] = { exports: {} }, e[s][0].call(o.exports, function (t) { var r = e[s][1][t]; return i(r || t) }, o, o.exports, t, e, r, n) } return r[s].exports } for (var a = "function" == typeof require && require, s = 0; s < n.length; s++)i(n[s]); return i }({
    1: [function (t, e, r) { r.encode = function (t) { for (var e, r, n, i, a, s, o = "", d = 0; d < t.length;)e = t.charCodeAt(d++), r = t.charCodeAt(d++), n = t.charCodeAt(d++), i = e >> 2, e = (3 & e) << 4 | r >> 4, a = (15 & r) << 2 | n >> 6, s = 63 & n, isNaN(r) ? a = s = 64 : isNaN(n) && (s = 64), o = o + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".charAt(i) + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".charAt(e) + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".charAt(a) + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".charAt(s); return o }, r.decode = function (t) { var e = "", r = 0; for (t = t.replace(/[^A-Za-z0-9\+\/=]/g, ""); r < t.length;) { var n = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(t.charAt(r++)), i = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(t.charAt(r++)), a = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(t.charAt(r++)), s = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(t.charAt(r++)); n = n << 2 | i >> 4, i = (15 & i) << 4 | a >> 2; var o = (3 & a) << 6 | s; e += String.fromCharCode(n), 64 != a && (e += String.fromCharCode(i)), 64 != s && (e += String.fromCharCode(o)) } return e } }, {}], 2: [function (t, e) { function r() { this.crc32 = this.uncompressedSize = this.compressedSize = 0, this.compressedContent = this.compressionMethod = null } r.prototype = { getContent: function () { return null }, getCompressedContent: function () { return null } }, e.exports = r }, {}], 3: [function (t, e, r) { r.STORE = { magic: "\0\0", compress: function (t) { return t }, uncompress: function (t) { return t }, compressInputType: null, uncompressInputType: null }, r.DEFLATE = t("./flate") }, { "./flate": 8 }], 4: [function (t, e) { var r = t("./utils"), n = [0, 1996959894, 3993919788, 2567524794, 124634137, 1886057615, 3915621685, 2657392035, 249268274, 2044508324, 3772115230, 2547177864, 162941995, 2125561021, 3887607047, 2428444049, 498536548, 1789927666, 4089016648, 2227061214, 450548861, 1843258603, 4107580753, 2211677639, 325883990, 1684777152, 4251122042, 2321926636, 335633487, 1661365465, 4195302755, 2366115317, 997073096, 1281953886, 3579855332, 2724688242, 1006888145, 1258607687, 3524101629, 2768942443, 901097722, 1119000684, 3686517206, 2898065728, 853044451, 1172266101, 3705015759, 2882616665, 651767980, 1373503546, 3369554304, 3218104598, 565507253, 1454621731, 3485111705, 3099436303, 671266974, 1594198024, 3322730930, 2970347812, 795835527, 1483230225, 3244367275, 3060149565, 1994146192, 31158534, 2563907772, 4023717930, 1907459465, 112637215, 2680153253, 3904427059, 2013776290, 251722036, 2517215374, 3775830040, 2137656763, 141376813, 2439277719, 3865271297, 1802195444, 476864866, 2238001368, 4066508878, 1812370925, 453092731, 2181625025, 4111451223, 1706088902, 314042704, 2344532202, 4240017532, 1658658271, 366619977, 2362670323, 4224994405, 1303535960, 984961486, 2747007092, 3569037538, 1256170817, 1037604311, 2765210733, 3554079995, 1131014506, 879679996, 2909243462, 3663771856, 1141124467, 855842277, 2852801631, 3708648649, 1342533948, 654459306, 3188396048, 3373015174, 1466479909, 544179635, 3110523913, 3462522015, 1591671054, 702138776, 2966460450, 3352799412, 1504918807, 783551873, 3082640443, 3233442989, 3988292384, 2596254646, 62317068, 1957810842, 3939845945, 2647816111, 81470997, 1943803523, 3814918930, 2489596804, 225274430, 2053790376, 3826175755, 2466906013, 167816743, 2097651377, 4027552580, 2265490386, 503444072, 1762050814, 4150417245, 2154129355, 426522225, 1852507879, 4275313526, 2312317920, 282753626, 1742555852, 4189708143, 2394877945, 397917763, 1622183637, 3604390888, 2714866558, 953729732, 1340076626, 3518719985, 2797360999, 1068828381, 1219638859, 3624741850, 2936675148, 906185462, 1090812512, 3747672003, 2825379669, 829329135, 1181335161, 3412177804, 3160834842, 628085408, 1382605366, 3423369109, 3138078467, 570562233, 1426400815, 3317316542, 2998733608, 733239954, 1555261956, 3268935591, 3050360625, 752459403, 1541320221, 2607071920, 3965973030, 1969922972, 40735498, 2617837225, 3943577151, 1913087877, 83908371, 2512341634, 3803740692, 2075208622, 213261112, 2463272603, 3855990285, 2094854071, 198958881, 2262029012, 4057260610, 1759359992, 534414190, 2176718541, 4139329115, 1873836001, 414664567, 2282248934, 4279200368, 1711684554, 285281116, 2405801727, 4167216745, 1634467795, 376229701, 2685067896, 3608007406, 1308918612, 956543938, 2808555105, 3495958263, 1231636301, 1047427035, 2932959818, 3654703836, 1088359270, 936918e3, 2847714899, 3736837829, 1202900863, 817233897, 3183342108, 3401237130, 1404277552, 615818150, 3134207493, 3453421203, 1423857449, 601450431, 3009837614, 3294710456, 1567103746, 711928724, 3020668471, 3272380065, 1510334235, 755167117]; e.exports = function (t, e) { if (void 0 === t || !t.length) return 0; var i = "string" !== r.getTypeOf(t); void 0 === e && (e = 0), e ^= -1; for (var a = 0, s = t.length; s > a; a++) { var o = i ? t[a] : t.charCodeAt(a); o = 255 & (e ^ o), o = n[o], e = e >>> 8 ^ o } return -1 ^ e } }, { "./utils": 21 }], 5: [function (t, e) { function r() { this.data = null, this.index = this.length = 0 } var n = t("./utils"); r.prototype = { checkOffset: function (t) { this.checkIndex(this.index + t) }, checkIndex: function (t) { if (this.length < t || 0 > t) throw Error("End of data reached (data length = " + this.length + ", asked index = " + t + "). Corrupted zip ?") }, setIndex: function (t) { this.checkIndex(t), this.index = t }, skip: function (t) { this.setIndex(this.index + t) }, byteAt: function () { }, readInt: function (t) { var e, r = 0; for (this.checkOffset(t), e = this.index + t - 1; e >= this.index; e--)r = (r << 8) + this.byteAt(e); return this.index += t, r }, readString: function (t) { return n.transformTo("string", this.readData(t)) }, readData: function () { }, lastIndexOfSignature: function () { }, readDate: function () { var t = this.readInt(4); return new Date(1980 + (t >> 25 & 127), (t >> 21 & 15) - 1, t >> 16 & 31, t >> 11 & 31, t >> 5 & 63, (31 & t) << 1) } }, e.exports = r }, { "./utils": 21 }], 6: [function (t, e, r) { r.base64 = !1, r.binary = !1, r.dir = !1, r.createFolders = !1, r.date = null, r.compression = null, r.compressionOptions = null, r.comment = null, r.unixPermissions = null, r.dosPermissions = null }, {}], 7: [function (t, e, r) { var n = t("./utils"); r.string2binary = function (t) { return n.string2binary(t) }, r.string2Uint8Array = function (t) { return n.transformTo("uint8array", t) }, r.uint8Array2String = function (t) { return n.transformTo("string", t) }, r.string2Blob = function (t) { return t = n.transformTo("arraybuffer", t), n.arrayBuffer2Blob(t) }, r.arrayBuffer2Blob = function (t) { return n.arrayBuffer2Blob(t) }, r.transformTo = function (t, e) { return n.transformTo(t, e) }, r.getTypeOf = function (t) { return n.getTypeOf(t) }, r.checkSupport = function (t) { return n.checkSupport(t) }, r.MAX_VALUE_16BITS = n.MAX_VALUE_16BITS, r.MAX_VALUE_32BITS = n.MAX_VALUE_32BITS, r.pretty = function (t) { return n.pretty(t) }, r.findCompression = function (t) { return n.findCompression(t) }, r.isRegExp = function (t) { return n.isRegExp(t) } }, { "./utils": 21 }], 8: [function (t, e, r) { e = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Uint32Array; var n = t("pako"); r.uncompressInputType = e ? "uint8array" : "array", r.compressInputType = e ? "uint8array" : "array", r.magic = "\b\0", r.compress = function (t, e) { return n.deflateRaw(t, { level: e.level || -1 }) }, r.uncompress = function (t) { return n.inflateRaw(t) } }, { pako: 24 }], 9: [function (t, e) { function r(t, e) { return this instanceof r ? (this.files = {}, this.comment = null, this.root = "", t && this.load(t, e), void (this.clone = function () { var t, e = new r; for (t in this) "function" != typeof this[t] && (e[t] = this[t]); return e })) : new r(t, e) } var n = t("./base64"); r.prototype = t("./object"), r.prototype.load = t("./load"), r.support = t("./support"), r.defaults = t("./defaults"), r.utils = t("./deprecatedPublicUtils"), r.base64 = { encode: function (t) { return n.encode(t) }, decode: function (t) { return n.decode(t) } }, r.compressions = t("./compressions"), e.exports = r }, { "./base64": 1, "./compressions": 3, "./defaults": 6, "./deprecatedPublicUtils": 7, "./load": 10, "./object": 13, "./support": 17 }], 10: [function (t, e) { var r = t("./base64"), n = t("./zipEntries"); e.exports = function (t, e) { var i; e = e || {}, e.base64 && (t = r.decode(t)); var a = new n(t, e); for (t = a.files, i = 0; i < t.length; i++) { var s = t[i]; this.file(s.fileName, s.decompressed, { binary: !0, optimizedBinaryString: !0, date: s.date, dir: s.dir, comment: s.fileComment.length ? s.fileComment : null, unixPermissions: s.unixPermissions, dosPermissions: s.dosPermissions, createFolders: e.createFolders }) } return a.zipComment.length && (this.comment = a.zipComment), this } }, { "./base64": 1, "./zipEntries": 22 }], 11: [function (t, e) { (function (t) { e.exports = function (e, r) { return new t(e, r) }, e.exports.test = function (e) { return t.isBuffer(e) } }).call(this, "undefined" != typeof Buffer ? Buffer : void 0) }, {}], 12: [function (t, e) { function r(t) { this.data = t, this.length = this.data.length, this.index = 0 } t = t("./uint8ArrayReader"), r.prototype = new t, r.prototype.readData = function (t) { this.checkOffset(t); var e = this.data.slice(this.index, this.index + t); return this.index += t, e }, e.exports = r }, { "./uint8ArrayReader": 18 }], 13: [function (t, e) { var r = t("./support"), n = t("./utils"), i = t("./crc32"), a = t("./signature"), s = t("./defaults"), o = t("./base64"), d = t("./compressions"), l = t("./compressedObject"), h = t("./nodeBuffer"), f = t("./utf8"), u = t("./stringWriter"), c = t("./uint8ArrayWriter"), p = function (t) { if (t._data instanceof l && (t._data = t._data.getContent(), t.options.binary = !0, t.options.base64 = !1, "uint8array" === n.getTypeOf(t._data))) { var e = t._data; t._data = new Uint8Array(e.length), 0 !== e.length && t._data.set(e, 0) } return t._data }, _ = function (t) { var e = p(t); return "string" === n.getTypeOf(e) ? !t.options.binary && r.nodebuffer ? h(e, "utf-8") : t.asBinary() : e }, m = function (t) { var e = p(this); return null === e || void 0 === e ? "" : (this.options.base64 && (e = o.decode(e)), e = t && this.options.binary ? x.utf8decode(e) : n.transformTo("string", e), t || this.options.binary || (e = n.transformTo("string", x.utf8encode(e))), e) }, g = function (t, e, r) { this.name = t, this.dir = r.dir, this.date = r.date, this.comment = r.comment, this.unixPermissions = r.unixPermissions, this.dosPermissions = r.dosPermissions, this._data = e, this.options = r, this._initialMetadata = { dir: r.dir, date: r.date } }; g.prototype = { asText: function () { return m.call(this, !0) }, asBinary: function () { return m.call(this, !1) }, asNodeBuffer: function () { var t = _(this); return n.transformTo("nodebuffer", t) }, asUint8Array: function () { var t = _(this); return n.transformTo("uint8array", t) }, asArrayBuffer: function () { return this.asUint8Array().buffer } }; var b = function (t, e) { var r, n = ""; for (r = 0; e > r; r++)n += String.fromCharCode(255 & t), t >>>= 8; return n }, v = function () { var t, e, r = {}; for (t = 0; t < arguments.length; t++)for (e in arguments[t]) arguments[t].hasOwnProperty(e) && void 0 === r[e] && (r[e] = arguments[t][e]); return r }, w = function (t, e, r) { var i = n.getTypeOf(e), a = r; if (a = a || {}, !0 !== a.base64 || null !== a.binary && void 0 !== a.binary || (a.binary = !0), a = v(a, s), a.date = a.date || new Date, null !== a.compression && (a.compression = a.compression.toUpperCase()), r = a, "string" == typeof r.unixPermissions && (r.unixPermissions = parseInt(r.unixPermissions, 8)), r.unixPermissions && 16384 & r.unixPermissions && (r.dir = !0), r.dosPermissions && 16 & r.dosPermissions && (r.dir = !0), r.dir && (t = y(t)), a = r.createFolders) { var o = t; "/" == o.slice(-1) && (o = o.substring(0, o.length - 1)), a = o.lastIndexOf("/"), a = o = 0 < a ? o.substring(0, a) : "" } if (a && k.call(this, o, !0), r.dir || null === e || void 0 === e) r.base64 = !1, r.binary = !1, e = null; else if ("string" === i) r.binary && !r.base64 && !0 !== r.optimizedBinaryString && (e = n.string2binary(e)); else { if (r.base64 = !1, r.binary = !0, !(i || e instanceof l)) throw Error("The data of '" + t + "' is in an unsupported format !"); "arraybuffer" === i && (e = n.transformTo("uint8array", e)) } return e = new g(t, e, r), this.files[t] = e, e }, y = function (t) { return "/" != t.slice(-1) && (t += "/"), t }, k = function (t, e) { return e = void 0 !== e && e, t = y(t), this.files[t] || w.call(this, t, null, { dir: !0, createFolders: e }), this.files[t] }, x = { load: function () { throw Error("Load method is not defined. Is the file jszip.json-load.js included ?") }, filter: function (t) { var e, r, n, i, a = []; for (e in this.files) this.files.hasOwnProperty(e) && (n = this.files[e], i = new g(n.name, n._data, v(n.options)), r = e.slice(this.root.length, e.length), e.slice(0, this.root.length) === this.root && t(r, i) && a.push(i)); return a }, file: function (t, e, r) { if (1 === arguments.length) { if (n.isRegExp(t)) { var i = t; return this.filter(function (t, e) { return !e.dir && i.test(t) }) } return this.filter(function (e, r) { return !r.dir && e === t })[0] || null } return t = this.root + t, w.call(this, t, e, r), this }, folder: function (t) { if (!t) return this; if (n.isRegExp(t)) return this.filter(function (e, r) { return r.dir && t.test(e) }); var e = k.call(this, this.root + t), r = this.clone(); return r.root = e.name, r }, remove: function (t) { t = this.root + t; var e = this.files[t]; if (e || ("/" != t.slice(-1) && (t += "/"), e = this.files[t]), e && !e.dir) delete this.files[t]; else { e = this.filter(function (e, r) { return r.name.slice(0, t.length) === t }); for (var r = 0; r < e.length; r++)delete this.files[e[r].name] } return this }, generate: function (t) { t = v(t || {}, { base64: !0, compression: "STORE", compressionOptions: null, type: "base64", platform: "DOS", comment: null, mimeType: "application/zip" }), n.checkSupport(t.type), "darwin" !== t.platform && "freebsd" !== t.platform && "linux" !== t.platform && "sunos" !== t.platform || (t.platform = "UNIX"), "win32" === t.platform && (t.platform = "DOS"); var e, r = [], s = e = 0, h = n.transformTo("string", this.utf8encode(t.comment || this.comment || "")); for (T in this.files) if (this.files.hasOwnProperty(T)) { var p = this.files[T], m = p.options.compression || t.compression.toUpperCase(), g = d[m]; if (!g) throw Error(m + " is not a valid compression method !"); var w = void 0; m = p; var y = p.options.compressionOptions || t.compressionOptions || {}, k = new l; m._data instanceof l ? (k.uncompressedSize = m._data.uncompressedSize, k.crc32 = m._data.crc32, 0 === k.uncompressedSize || m.dir ? (g = d.STORE, k.compressedContent = "", k.crc32 = 0) : m._data.compressionMethod === g.magic ? k.compressedContent = m._data.getCompressedContent() : (w = m._data.getContent(), k.compressedContent = g.compress(n.transformTo(g.compressInputType, w), y))) : (w = _(m), (!w || 0 === w.length || m.dir) && (g = d.STORE, w = ""), k.uncompressedSize = w.length, k.crc32 = i(w), k.compressedContent = g.compress(n.transformTo(g.compressInputType, w), y)), k.compressedSize = k.compressedContent.length, k.compressionMethod = g.magic, m = k; var x = p; p = m, w = e; var z = t.platform; p.compressedContent, g = n.transformTo("string", f.utf8encode(x.name)); var E = x.comment || ""; y = n.transformTo("string", f.utf8encode(E)), k = g.length !== x.name.length; var A = y.length !== E.length, C = x.options, S = E = "", I = "", B = x._initialMetadata.dir !== x.dir ? x.dir : C.dir; C = x._initialMetadata.date !== x.date ? x.date : C.date; var O = 0; if (B && (O |= 16), "UNIX" === z) { z = 798; var R = x.unixPermissions; x = R, R || (x = B ? 16893 : 33204), B = (65535 & x) << 16, O |= B } else z = 20, O |= 63 & (x.dosPermissions || 0); x = C.getHours(), x <<= 6, x |= C.getMinutes(), x <<= 5, x |= C.getSeconds() / 2, B = C.getFullYear() - 1980, B <<= 4, B |= C.getMonth() + 1, B <<= 5, B |= C.getDate(), k && (S = b(1, 1) + b(i(g), 4) + g, E += "up" + b(S.length, 2) + S), A && (I = b(1, 1) + b(this.crc32(y), 4) + y, E += "uc" + b(I.length, 2) + I), S = "", S += "\n\0", S += k || A ? "\0\b" : "\0\0", S += p.compressionMethod, S += b(x, 2), S += b(B, 2), S += b(p.crc32, 4), S += b(p.compressedSize, 4), S += b(p.uncompressedSize, 4), S += b(g.length, 2), S += b(E.length, 2), k = a.LOCAL_FILE_HEADER + S + g + E, w = a.CENTRAL_FILE_HEADER + b(z, 2) + S + b(y.length, 2) + "\0\0\0\0" + b(O, 4) + b(w, 4) + g + E + y, p = { fileRecord: k, dirRecord: w, compressedObject: p }, e += p.fileRecord.length + m.compressedSize, s += p.dirRecord.length, r.push(p) } h = a.CENTRAL_DIRECTORY_END + "\0\0\0\0" + b(r.length, 2) + b(r.length, 2) + b(s, 4) + b(e, 4) + b(h.length, 2) + h; var T = t.type.toLowerCase(); for (e = "uint8array" === T || "arraybuffer" === T || "blob" === T || "nodebuffer" === T ? new c(e + s + h.length) : new u(e + s + h.length), s = 0; s < r.length; s++)e.append(r[s].fileRecord), e.append(r[s].compressedObject.compressedContent); for (s = 0; s < r.length; s++)e.append(r[s].dirRecord); switch (e.append(h), r = e.finalize(), t.type.toLowerCase()) { case "uint8array": case "arraybuffer": case "nodebuffer": return n.transformTo(t.type.toLowerCase(), r); case "blob": return n.arrayBuffer2Blob(n.transformTo("arraybuffer", r), t.mimeType); case "base64": return t.base64 ? o.encode(r) : r; default: return r } }, crc32: function (t, e) { return i(t, e) }, utf8encode: function (t) { return n.transformTo("string", f.utf8encode(t)) }, utf8decode: function (t) { return f.utf8decode(t) } }; e.exports = x }, { "./base64": 1, "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./defaults": 6, "./nodeBuffer": 11, "./signature": 14, "./stringWriter": 16, "./support": 17, "./uint8ArrayWriter": 19, "./utf8": 20, "./utils": 21 }], 14: [function (t, e, r) { r.LOCAL_FILE_HEADER = "PK", r.CENTRAL_FILE_HEADER = "PK", r.CENTRAL_DIRECTORY_END = "PK", r.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK", r.ZIP64_CENTRAL_DIRECTORY_END = "PK", r.DATA_DESCRIPTOR = "PK\b" }, {}], 15: [function (t, e) { function r(t, e) { this.data = t, e || (this.data = i.string2binary(this.data)), this.length = this.data.length, this.index = 0 } var n = t("./dataReader"), i = t("./utils"); r.prototype = new n, r.prototype.byteAt = function (t) { return this.data.charCodeAt(t) }, r.prototype.lastIndexOfSignature = function (t) { return this.data.lastIndexOf(t) }, r.prototype.readData = function (t) { this.checkOffset(t); var e = this.data.slice(this.index, this.index + t); return this.index += t, e }, e.exports = r }, { "./dataReader": 5, "./utils": 21 }], 16: [function (t, e) { var r = t("./utils"); t = function () { this.data = [] }, t.prototype = { append: function (t) { t = r.transformTo("string", t), this.data.push(t) }, finalize: function () { return this.data.join("") } }, e.exports = t }, { "./utils": 21 }], 17: [function (t, e, r) { if (t = "undefined" != typeof Buffer ? Buffer : void 0, r.base64 = !0, r.array = !0, r.string = !0, r.arraybuffer = "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array, r.nodebuffer = void 0 !== t, r.uint8array = "undefined" != typeof Uint8Array, "undefined" == typeof ArrayBuffer) r.blob = !1; else { t = new ArrayBuffer(0); try { r.blob = 0 === new Blob([t], { type: "application/zip" }).size } catch (e) { try { var n = new (window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder); n.append(t), r.blob = 0 === n.getBlob("application/zip").size } catch (t) { r.blob = !1 } } } }, {}], 18: [function (t, e) { function r(t) { t && (this.data = t, this.length = this.data.length, this.index = 0) } t = t("./dataReader"), r.prototype = new t, r.prototype.byteAt = function (t) { return this.data[t] }, r.prototype.lastIndexOfSignature = function (t) { var e = t.charCodeAt(0), r = t.charCodeAt(1), n = t.charCodeAt(2); t = t.charCodeAt(3); for (var i = this.length - 4; 0 <= i; --i)if (this.data[i] === e && this.data[i + 1] === r && this.data[i + 2] === n && this.data[i + 3] === t) return i; return -1 }, r.prototype.readData = function (t) { if (this.checkOffset(t), 0 === t) return new Uint8Array(0); var e = this.data.subarray(this.index, this.index + t); return this.index += t, e }, e.exports = r }, { "./dataReader": 5 }], 19: [function (t, e) { var r = t("./utils"); t = function (t) { this.data = new Uint8Array(t), this.index = 0 }, t.prototype = { append: function (t) { 0 !== t.length && (t = r.transformTo("uint8array", t), this.data.set(t, this.index), this.index += t.length) }, finalize: function () { return this.data } }, e.exports = t }, { "./utils": 21 }], 20: [function (t, e, r) { var n = t("./utils"), i = t("./support"), a = t("./nodeBuffer"), s = Array(256); for (t = 0; 256 > t; t++)s[t] = 252 <= t ? 6 : 248 <= t ? 5 : 240 <= t ? 4 : 224 <= t ? 3 : 192 <= t ? 2 : 1; s[254] = s[254] = 1; var o = function (t) { var e, r, i, a, o = t.length, d = Array(2 * o); for (e = r = 0; o > e;)if (128 > (i = t[e++])) d[r++] = i; else if (4 < (a = s[i])) d[r++] = 65533, e += a - 1; else { for (i &= 2 === a ? 31 : 3 === a ? 15 : 7; 1 < a && o > e;)i = i << 6 | 63 & t[e++], a--; 1 < a ? d[r++] = 65533 : 65536 > i ? d[r++] = i : (i -= 65536, d[r++] = 55296 | i >> 10 & 1023, d[r++] = 56320 | 1023 & i) } return d.length !== r && (d.subarray ? d = d.subarray(0, r) : d.length = r), n.applyFromCharCode(d) }; r.utf8encode = function (t) { if (i.nodebuffer) t = a(t, "utf-8"); else { var e, r, n, s = t.length, o = 0; for (r = 0; s > r; r++) { var d = t.charCodeAt(r); 55296 == (64512 & d) && s > r + 1 && 56320 == (64512 & (e = t.charCodeAt(r + 1))) && (d = 65536 + (d - 55296 << 10) + (e - 56320), r++), o += 128 > d ? 1 : 2048 > d ? 2 : 65536 > d ? 3 : 4 } var l = i.uint8array ? new Uint8Array(o) : Array(o); for (r = n = 0; o > n; r++)d = t.charCodeAt(r), 55296 == (64512 & d) && s > r + 1 && 56320 == (64512 & (e = t.charCodeAt(r + 1))) && (d = 65536 + (d - 55296 << 10) + (e - 56320), r++), 128 > d ? l[n++] = d : 2048 > d ? (l[n++] = 192 | d >>> 6, l[n++] = 128 | 63 & d) : 65536 > d ? (l[n++] = 224 | d >>> 12, l[n++] = 128 | d >>> 6 & 63, l[n++] = 128 | 63 & d) : (l[n++] = 240 | d >>> 18, l[n++] = 128 | d >>> 12 & 63, l[n++] = 128 | d >>> 6 & 63, l[n++] = 128 | 63 & d); t = l } return t }, r.utf8decode = function (t) { if (i.nodebuffer) return n.transformTo("nodebuffer", t).toString("utf-8"); t = n.transformTo(i.uint8array ? "uint8array" : "array", t); for (var e = [], r = 0, a = t.length; a > r;) { var d, l = Math.min(r + 65536, a); for (l = l || t.length, l > t.length && (l = t.length), d = l - 1; 0 <= d && 128 == (192 & t[d]);)d--; d = 0 > d ? l : 0 === d ? l : d + s[t[d]] > l ? d : l, e.push(o(i.uint8array ? t.subarray(r, d) : t.slice(r, d))), r = d } return e.join("") } }, { "./nodeBuffer": 11, "./support": 17, "./utils": 21 }], 21: [function (t, e, r) { function n(t) { return t } function i(t, e) { for (var r = 0; r < t.length; ++r)e[r] = 255 & t.charCodeAt(r); return e } function a(t) { var e = 65536, n = [], i = t.length, a = r.getTypeOf(t), s = 0, o = !0; try { switch (a) { case "uint8array": String.fromCharCode.apply(null, new Uint8Array(0)); break; case "nodebuffer": String.fromCharCode.apply(null, l(0)) } } catch (t) { o = !1 } if (!o) { for (e = "", n = 0; n < t.length; n++)e += String.fromCharCode(t[n]); return e } for (; i > s && 1 < e;)try { n.push("array" === a || "nodebuffer" === a ? String.fromCharCode.apply(null, t.slice(s, Math.min(s + e, i))) : String.fromCharCode.apply(null, t.subarray(s, Math.min(s + e, i)))), s += e } catch (t) { e = Math.floor(e / 2) } return n.join("") } function s(t, e) { for (var r = 0; r < t.length; r++)e[r] = t[r]; return e } var o = t("./support"), d = t("./compressions"), l = t("./nodeBuffer"); r.string2binary = function (t) { for (var e = "", r = 0; r < t.length; r++)e += String.fromCharCode(255 & t.charCodeAt(r)); return e }, r.arrayBuffer2Blob = function (t, e) { r.checkSupport("blob"), e = e || "application/zip"; try { return new Blob([t], { type: e }) } catch (r) { try { var n = new (window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder); return n.append(t), n.getBlob(e) } catch (t) { throw Error("Bug : can't construct the Blob.") } } }, r.applyFromCharCode = a; var h = {}; h.string = { string: n, array: function (t) { return i(t, Array(t.length)) }, arraybuffer: function (t) { return h.string.uint8array(t).buffer }, uint8array: function (t) { return i(t, new Uint8Array(t.length)) }, nodebuffer: function (t) { return i(t, l(t.length)) } }, h.array = { string: a, array: n, arraybuffer: function (t) { return new Uint8Array(t).buffer }, uint8array: function (t) { return new Uint8Array(t) }, nodebuffer: function (t) { return l(t) } }, h.arraybuffer = { string: function (t) { return a(new Uint8Array(t)) }, array: function (t) { return s(new Uint8Array(t), Array(t.byteLength)) }, arraybuffer: n, uint8array: function (t) { return new Uint8Array(t) }, nodebuffer: function (t) { return l(new Uint8Array(t)) } }, h.uint8array = { string: a, array: function (t) { return s(t, Array(t.length)) }, arraybuffer: function (t) { return t.buffer }, uint8array: n, nodebuffer: function (t) { return l(t) } }, h.nodebuffer = { string: a, array: function (t) { return s(t, Array(t.length)) }, arraybuffer: function (t) { return h.nodebuffer.uint8array(t).buffer }, uint8array: function (t) { return s(t, new Uint8Array(t.length)) }, nodebuffer: n }, r.transformTo = function (t, e) { if (e || (e = ""), !t) return e; r.checkSupport(t); var n = r.getTypeOf(e); return h[n][t](e) }, r.getTypeOf = function (t) { return "string" == typeof t ? "string" : "[object Array]" === Object.prototype.toString.call(t) ? "array" : o.nodebuffer && l.test(t) ? "nodebuffer" : o.uint8array && t instanceof Uint8Array ? "uint8array" : o.arraybuffer && t instanceof ArrayBuffer ? "arraybuffer" : void 0 }, r.checkSupport = function (t) { if (!o[t.toLowerCase()]) throw Error(t + " is not supported by this browser") }, r.MAX_VALUE_16BITS = 65535, r.MAX_VALUE_32BITS = -1, r.pretty = function (t) { var e, r = ""; for (e = 0; e < (t || "").length; e++) { var n = t.charCodeAt(e); r += "\\x" + (16 > n ? "0" : "") + n.toString(16).toUpperCase() } return r }, r.findCompression = function (t) { for (var e in d) if (d.hasOwnProperty(e) && d[e].magic === t) return d[e]; return null }, r.isRegExp = function (t) { return "[object RegExp]" === Object.prototype.toString.call(t) } }, { "./compressions": 3, "./nodeBuffer": 11, "./support": 17 }], 22: [function (t, e) { function r(t, e) { this.files = [], this.loadOptions = e, t && this.load(t) } var n = t("./stringReader"), i = t("./nodeBufferReader"), a = t("./uint8ArrayReader"), s = t("./utils"), o = t("./signature"), d = t("./zipEntry"), l = t("./support"), h = t("./object"); r.prototype = { checkSignature: function (t) { var e = this.reader.readString(4); if (e !== t) throw Error("Corrupted zip or bug : unexpected signature (" + s.pretty(e) + ", expected " + s.pretty(t) + ")") }, readBlockEndOfCentral: function () { this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2), this.zipComment = this.reader.readString(this.zipCommentLength), this.zipComment = h.utf8decode(this.zipComment) }, readBlockZip64EndOfCentral: function () { this.zip64EndOfCentralSize = this.reader.readInt(8), this.versionMadeBy = this.reader.readString(2), this.versionNeeded = this.reader.readInt(2), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {}; for (var t, e, r, n = this.zip64EndOfCentralSize - 44; 0 < n;)t = this.reader.readInt(2), e = this.reader.readInt(4), r = this.reader.readString(e), this.zip64ExtensibleData[t] = { id: t, length: e, value: r } }, readBlockZip64EndOfCentralLocator: function () { if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount) throw Error("Multi-volumes zip are not supported") }, readLocalFiles: function () { var t; for (t = 0; t < this.files.length; t++) { var e = this.files[t]; this.reader.setIndex(e.localHeaderOffset), this.checkSignature(o.LOCAL_FILE_HEADER), e.readLocalPart(this.reader), e.handleUTF8(), e.processAttributes() } }, readCentralDir: function () { for (this.reader.setIndex(this.centralDirOffset); this.reader.readString(4) === o.CENTRAL_FILE_HEADER;) { var t = new d({ zip64: this.zip64 }, this.loadOptions); t.readCentralPart(this.reader), this.files.push(t) } }, readEndOfCentral: function () { var t = this.reader.lastIndexOfSignature(o.CENTRAL_DIRECTORY_END); if (-1 === t) { t = !0; try { this.reader.setIndex(0), this.checkSignature(o.LOCAL_FILE_HEADER), t = !1 } catch (t) { } throw Error(t ? "Can't find end of central directory : is this a zip file ? If it is, see http://stuk.github.io/jszip.json/documentation/howto/read_zip.html" : "Corrupted zip : can't find end of central directory") } if (this.reader.setIndex(t), this.checkSignature(o.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === s.MAX_VALUE_16BITS || this.diskWithCentralDirStart === s.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === s.MAX_VALUE_16BITS || this.centralDirRecords === s.MAX_VALUE_16BITS || this.centralDirSize === s.MAX_VALUE_32BITS || this.centralDirOffset === s.MAX_VALUE_32BITS) { if (this.zip64 = !0, -1 === (t = this.reader.lastIndexOfSignature(o.ZIP64_CENTRAL_DIRECTORY_LOCATOR))) throw Error("Corrupted zip : can't find the ZIP64 end of central directory locator"); this.reader.setIndex(t), this.checkSignature(o.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(o.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral() } }, prepareReader: function (t) { var e = s.getTypeOf(t); this.reader = "string" !== e || l.uint8array ? "nodebuffer" === e ? new i(t) : new a(s.transformTo("uint8array", t)) : new n(t, this.loadOptions.optimizedBinaryString) }, load: function (t) { this.prepareReader(t), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles() } }, e.exports = r }, { "./nodeBufferReader": 12, "./object": 13, "./signature": 14, "./stringReader": 15, "./support": 17, "./uint8ArrayReader": 18, "./utils": 21, "./zipEntry": 23 }], 23: [function (t, e) { function r(t, e) { this.options = t, this.loadOptions = e } var n = t("./stringReader"), i = t("./utils"), a = t("./compressedObject"), s = t("./object"); r.prototype = { isEncrypted: function () { return 1 == (1 & this.bitFlag) }, useUTF8: function () { return 2048 == (2048 & this.bitFlag) }, prepareCompressedContent: function (t, e, r) { return function () { var n = t.index; t.setIndex(e); var i = t.readData(r); return t.setIndex(n), i } }, prepareContent: function (t, e, r, n, a) { return function () { var t = i.transformTo(n.uncompressInputType, this.getCompressedContent()); if (t = n.uncompress(t), t.length !== a) throw Error("Bug : uncompressed data size mismatch"); return t } }, readLocalPart: function (t) { var e, r; if (t.skip(22), this.fileNameLength = t.readInt(2), r = t.readInt(2), this.fileName = t.readString(this.fileNameLength), t.skip(r), -1 == this.compressedSize || -1 == this.uncompressedSize) throw Error("Bug or corrupted zip : didn't get enough informations from the central directory (compressedSize == -1 || uncompressedSize == -1)"); if (null === (e = i.findCompression(this.compressionMethod))) throw Error("Corrupted zip : compression " + i.pretty(this.compressionMethod) + " unknown (inner file : " + this.fileName + ")"); if (this.decompressed = new a, this.decompressed.compressedSize = this.compressedSize, this.decompressed.uncompressedSize = this.uncompressedSize, this.decompressed.crc32 = this.crc32, this.decompressed.compressionMethod = this.compressionMethod, this.decompressed.getCompressedContent = this.prepareCompressedContent(t, t.index, this.compressedSize, e), this.decompressed.getContent = this.prepareContent(t, t.index, this.compressedSize, e, this.uncompressedSize), this.loadOptions.checkCRC32 && (this.decompressed = i.transformTo("string", this.decompressed.getContent()), s.crc32(this.decompressed) !== this.crc32)) throw Error("Corrupted zip : CRC32 mismatch") }, readCentralPart: function (t) { if (this.versionMadeBy = t.readInt(2), this.versionNeeded = t.readInt(2), this.bitFlag = t.readInt(2), this.compressionMethod = t.readString(2), this.date = t.readDate(), this.crc32 = t.readInt(4), this.compressedSize = t.readInt(4), this.uncompressedSize = t.readInt(4), this.fileNameLength = t.readInt(2), this.extraFieldsLength = t.readInt(2), this.fileCommentLength = t.readInt(2), this.diskNumberStart = t.readInt(2), this.internalFileAttributes = t.readInt(2), this.externalFileAttributes = t.readInt(4), this.localHeaderOffset = t.readInt(4), this.isEncrypted()) throw Error("Encrypted zip are not supported"); this.fileName = t.readString(this.fileNameLength), this.readExtraFields(t), this.parseZIP64ExtraField(t), this.fileComment = t.readString(this.fileCommentLength) }, processAttributes: function () { this.dosPermissions = this.unixPermissions = null; var t = this.versionMadeBy >> 8; this.dir = !!(16 & this.externalFileAttributes), 0 === t && (this.dosPermissions = 63 & this.externalFileAttributes), 3 === t && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || "/" !== this.fileName.slice(-1) || (this.dir = !0) }, parseZIP64ExtraField: function () { if (this.extraFields[1]) { var t = new n(this.extraFields[1].value); this.uncompressedSize === i.MAX_VALUE_32BITS && (this.uncompressedSize = t.readInt(8)), this.compressedSize === i.MAX_VALUE_32BITS && (this.compressedSize = t.readInt(8)), this.localHeaderOffset === i.MAX_VALUE_32BITS && (this.localHeaderOffset = t.readInt(8)), this.diskNumberStart === i.MAX_VALUE_32BITS && (this.diskNumberStart = t.readInt(4)) } }, readExtraFields: function (t) { var e = t.index; for (this.extraFields = this.extraFields || {}; t.index < e + this.extraFieldsLength;) { var r = t.readInt(2), n = t.readInt(2), i = t.readString(n); this.extraFields[r] = { id: r, length: n, value: i } } }, handleUTF8: function () { if (this.useUTF8()) this.fileName = s.utf8decode(this.fileName), this.fileComment = s.utf8decode(this.fileComment); else { var t = this.findExtraFieldUnicodePath(); null !== t && (this.fileName = t), t = this.findExtraFieldUnicodeComment(), null !== t && (this.fileComment = t) } }, findExtraFieldUnicodePath: function () { var t = this.extraFields[28789]; if (t) { var e = new n(t.value); return 1 !== e.readInt(1) ? null : s.crc32(this.fileName) !== e.readInt(4) ? null : s.utf8decode(e.readString(t.length - 5)) } return null }, findExtraFieldUnicodeComment: function () { var t = this.extraFields[25461]; if (t) { var e = new n(t.value); return 1 !== e.readInt(1) ? null : s.crc32(this.fileComment) !== e.readInt(4) ? null : s.utf8decode(e.readString(t.length - 5)) } return null } }, e.exports = r }, { "./compressedObject": 2, "./object": 13, "./stringReader": 15, "./utils": 21 }], 24: [function (t, e) {
      var r = t("./lib/utils/common").assign, n = t("./lib/deflate"), i = t("./lib/inflate"); t = t("./lib/zlib/constants"); var a = {}; r(a, n, i, t), e.exports = a
    }, { "./lib/deflate": 25, "./lib/inflate": 26, "./lib/utils/common": 27, "./lib/zlib/constants": 30 }], 25: [function (t, e, r) { function n(t, e) { if (e = new l(e), e.push(t, !0), e.err) throw e.msg; return e.result } var i = t("./zlib/deflate.js"), a = t("./utils/common"), s = t("./utils/strings"), o = t("./zlib/messages"), d = t("./zlib/zstream"), l = function (t) { t = this.options = a.assign({ level: -1, method: 8, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: 0, to: "" }, t || {}), t.raw && 0 < t.windowBits ? t.windowBits = -t.windowBits : t.gzip && 0 < t.windowBits && 16 > t.windowBits && (t.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new d, this.strm.avail_out = 0; var e = i.deflateInit2(this.strm, t.level, t.method, t.windowBits, t.memLevel, t.strategy); if (0 !== e) throw Error(o[e]); t.header && i.deflateSetHeader(this.strm, t.header) }; l.prototype.push = function (t, e) { var r, n = this.strm, o = this.options.chunkSize; if (this.ended) return !1; e = e === ~~e ? e : !0 === e ? 4 : 0, n.input = "string" == typeof t ? s.string2buf(t) : t, n.next_in = 0, n.avail_in = n.input.length; do { if (0 === n.avail_out && (n.output = new a.Buf8(o), n.next_out = 0, n.avail_out = o), 1 !== (r = i.deflate(n, e)) && 0 !== r) return this.onEnd(r), this.ended = !0, !1; (0 === n.avail_out || 0 === n.avail_in && 4 === e) && this.onData("string" === this.options.to ? s.buf2binstring(a.shrinkBuf(n.output, n.next_out)) : a.shrinkBuf(n.output, n.next_out)) } while ((0 < n.avail_in || 0 === n.avail_out) && 1 !== r); return 4 !== e || (r = i.deflateEnd(this.strm), this.onEnd(r), this.ended = !0, 0 === r) }, l.prototype.onData = function (t) { this.chunks.push(t) }, l.prototype.onEnd = function (t) { 0 === t && (this.result = "string" === this.options.to ? this.chunks.join("") : a.flattenChunks(this.chunks)), this.chunks = [], this.err = t, this.msg = this.strm.msg }, r.Deflate = l, r.deflate = n, r.deflateRaw = function (t, e) { return e = e || {}, e.raw = !0, n(t, e) }, r.gzip = function (t, e) { return e = e || {}, e.gzip = !0, n(t, e) } }, { "./utils/common": 27, "./utils/strings": 28, "./zlib/deflate.js": 32, "./zlib/messages": 37, "./zlib/zstream": 39 }], 26: [function (t, e, r) { function n(t, e) { if (e = new f(e), e.push(t, !0), e.err) throw e.msg; return e.result } var i = t("./zlib/inflate.js"), a = t("./utils/common"), s = t("./utils/strings"), o = t("./zlib/constants"), d = t("./zlib/messages"), l = t("./zlib/zstream"), h = t("./zlib/gzheader"), f = function (t) { var e = this.options = a.assign({ chunkSize: 16384, windowBits: 0, to: "" }, t || {}); if (e.raw && 0 <= e.windowBits && 16 > e.windowBits && (e.windowBits = -e.windowBits, 0 === e.windowBits && (e.windowBits = -15)), !(0 <= e.windowBits && 16 > e.windowBits) || t && t.windowBits || (e.windowBits += 32), 15 < e.windowBits && 48 > e.windowBits && 0 == (15 & e.windowBits) && (e.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new l, this.strm.avail_out = 0, (t = i.inflateInit2(this.strm, e.windowBits)) !== o.Z_OK) throw Error(d[t]); this.header = new h, i.inflateGetHeader(this.strm, this.header) }; f.prototype.push = function (t, e) { var r, n, d, l, h = this.strm, f = this.options.chunkSize; if (this.ended) return !1; e = e === ~~e ? e : !0 === e ? o.Z_FINISH : o.Z_NO_FLUSH, h.input = "string" == typeof t ? s.binstring2buf(t) : t, h.next_in = 0, h.avail_in = h.input.length; do { if (0 === h.avail_out && (h.output = new a.Buf8(f), h.next_out = 0, h.avail_out = f), (r = i.inflate(h, o.Z_NO_FLUSH)) !== o.Z_STREAM_END && r !== o.Z_OK) return this.onEnd(r), this.ended = !0, !1; h.next_out && (0 === h.avail_out || r === o.Z_STREAM_END || 0 === h.avail_in && e === o.Z_FINISH) && ("string" === this.options.to ? (n = s.utf8border(h.output, h.next_out), d = h.next_out - n, l = s.buf2string(h.output, n), h.next_out = d, h.avail_out = f - d, d && a.arraySet(h.output, h.output, n, d, 0), this.onData(l)) : this.onData(a.shrinkBuf(h.output, h.next_out))) } while (0 < h.avail_in && r !== o.Z_STREAM_END); return r === o.Z_STREAM_END && (e = o.Z_FINISH), e !== o.Z_FINISH || (r = i.inflateEnd(this.strm), this.onEnd(r), this.ended = !0, r === o.Z_OK) }, f.prototype.onData = function (t) { this.chunks.push(t) }, f.prototype.onEnd = function (t) { t === o.Z_OK && (this.result = "string" === this.options.to ? this.chunks.join("") : a.flattenChunks(this.chunks)), this.chunks = [], this.err = t, this.msg = this.strm.msg }, r.Inflate = f, r.inflate = n, r.inflateRaw = function (t, e) { return e = e || {}, e.raw = !0, n(t, e) }, r.ungzip = n }, { "./utils/common": 27, "./utils/strings": 28, "./zlib/constants": 30, "./zlib/gzheader": 33, "./zlib/inflate.js": 35, "./zlib/messages": 37, "./zlib/zstream": 39 }], 27: [function (t, e, r) { t = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Int32Array, r.assign = function (t) { for (var e = Array.prototype.slice.call(arguments, 1); e.length;) { var r = e.shift(); if (r) { if ("object" != (void 0 === r ? "undefined" : _typeof(r))) throw new TypeError(r + "must be non-object"); for (var n in r) r.hasOwnProperty(n) && (t[n] = r[n]) } } return t }, r.shrinkBuf = function (t, e) { return t.length === e ? t : t.subarray ? t.subarray(0, e) : (t.length = e, t) }; var n = { arraySet: function (t, e, r, n, i) { if (e.subarray && t.subarray) return void t.set(e.subarray(r, r + n), i); for (var a = 0; n > a; a++)t[i + a] = e[r + a] }, flattenChunks: function (t) { var e, r, n = r = 0; for (e = t.length; e > n; n++)r += t[n].length; var i = new Uint8Array(r); for (n = r = 0, e = t.length; e > n; n++) { var a = t[n]; i.set(a, r), r += a.length } return i } }, i = { arraySet: function (t, e, r, n, i) { for (var a = 0; n > a; a++)t[i + a] = e[r + a] }, flattenChunks: function (t) { return [].concat.apply([], t) } }; r.setTyped = function (t) { t ? (r.Buf8 = Uint8Array, r.Buf16 = Uint16Array, r.Buf32 = Int32Array, r.assign(r, n)) : (r.Buf8 = Array, r.Buf16 = Array, r.Buf32 = Array, r.assign(r, i)) }, r.setTyped(t) }, {}], 28: [function (t, e, r) { function n(t, e) { if (65537 > e && (t.subarray && s || !t.subarray && a)) return String.fromCharCode.apply(null, i.shrinkBuf(t, e)); for (var r = "", n = 0; e > n; n++)r += String.fromCharCode(t[n]); return r } var i = t("./common"), a = !0, s = !0; try { String.fromCharCode.apply(null, [0]) } catch (t) { a = !1 } try { String.fromCharCode.apply(null, new Uint8Array(1)) } catch (t) { s = !1 } var o = new i.Buf8(256); for (t = 0; 256 > t; t++)o[t] = 252 <= t ? 6 : 248 <= t ? 5 : 240 <= t ? 4 : 224 <= t ? 3 : 192 <= t ? 2 : 1; o[254] = o[254] = 1, r.string2buf = function (t) { var e, r, n, a = t.length, s = 0; for (r = 0; a > r; r++) { var o = t.charCodeAt(r); 55296 == (64512 & o) && a > r + 1 && 56320 == (64512 & (e = t.charCodeAt(r + 1))) && (o = 65536 + (o - 55296 << 10) + (e - 56320), r++), s += 128 > o ? 1 : 2048 > o ? 2 : 65536 > o ? 3 : 4 } var d = new i.Buf8(s); for (r = n = 0; s > n; r++)o = t.charCodeAt(r), 55296 == (64512 & o) && a > r + 1 && 56320 == (64512 & (e = t.charCodeAt(r + 1))) && (o = 65536 + (o - 55296 << 10) + (e - 56320), r++), 128 > o ? d[n++] = o : 2048 > o ? (d[n++] = 192 | o >>> 6, d[n++] = 128 | 63 & o) : 65536 > o ? (d[n++] = 224 | o >>> 12, d[n++] = 128 | o >>> 6 & 63, d[n++] = 128 | 63 & o) : (d[n++] = 240 | o >>> 18, d[n++] = 128 | o >>> 12 & 63, d[n++] = 128 | o >>> 6 & 63, d[n++] = 128 | 63 & o); return d }, r.buf2binstring = function (t) { return n(t, t.length) }, r.binstring2buf = function (t) { for (var e = new i.Buf8(t.length), r = 0, n = e.length; n > r; r++)e[r] = t.charCodeAt(r); return e }, r.buf2string = function (t, e) { var r, i, a, s = e || t.length, d = Array(2 * s); for (e = r = 0; s > e;)if (128 > (i = t[e++])) d[r++] = i; else if (4 < (a = o[i])) d[r++] = 65533, e += a - 1; else { for (i &= 2 === a ? 31 : 3 === a ? 15 : 7; 1 < a && s > e;)i = i << 6 | 63 & t[e++], a--; 1 < a ? d[r++] = 65533 : 65536 > i ? d[r++] = i : (i -= 65536, d[r++] = 55296 | i >> 10 & 1023, d[r++] = 56320 | 1023 & i) } return n(d, r) }, r.utf8border = function (t, e) { var r; for (e = e || t.length, e > t.length && (e = t.length), r = e - 1; 0 <= r && 128 == (192 & t[r]);)r--; return 0 > r ? e : 0 === r ? e : r + o[t[r]] > e ? r : e } }, { "./common": 27 }], 29: [function (t, e) { e.exports = function (t, e, r, n) { var i = 65535 & t | 0; t = t >>> 16 & 65535 | 0; for (var a; 0 !== r;) { a = 2e3 < r ? 2e3 : r, r -= a; do { i = i + e[n++] | 0, t = t + i | 0 } while (--a); i %= 65521, t %= 65521 } return i | t << 16 | 0 } }, {}], 30: [function (t, e) { e.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 } }, {}], 31: [function (t, e) { var r = function () { for (var t, e = [], r = 0; 256 > r; r++) { t = r; for (var n = 0; 8 > n; n++)t = 1 & t ? 3988292384 ^ t >>> 1 : t >>> 1; e[r] = t } return e }(); e.exports = function (t, e, n, i) { for (n = i + n, t ^= -1; n > i; i++)t = t >>> 8 ^ r[255 & (t ^ e[i])]; return -1 ^ t } }, {}], 32: [function (t, e, r) { function n(t, e) { return t.msg = y[e], e } function i(t) { for (var e = t.length; 0 <= --e;)t[e] = 0 } function a(t) { var e = t.state, r = e.pending; r > t.avail_out && (r = t.avail_out), 0 !== r && (g.arraySet(t.output, e.pending_buf, e.pending_out, r, t.next_out), t.next_out += r, e.pending_out += r, t.total_out += r, t.avail_out -= r, e.pending -= r, 0 === e.pending && (e.pending_out = 0)) } function s(t, e) { b._tr_flush_block(t, 0 <= t.block_start ? t.block_start : -1, t.strstart - t.block_start, e), t.block_start = t.strstart, a(t.strm) } function o(t, e) { t.pending_buf[t.pending++] = e } function d(t, e) { t.pending_buf[t.pending++] = e >>> 8 & 255, t.pending_buf[t.pending++] = 255 & e } function l(t, e) { var r, n, i = t.max_chain_length, a = t.strstart, s = t.prev_length, o = t.nice_match, d = t.strstart > t.w_size - Z ? t.strstart - (t.w_size - Z) : 0, l = t.window, h = t.w_mask, f = t.prev, u = t.strstart + F, c = l[a + s - 1], p = l[a + s]; t.prev_length >= t.good_match && (i >>= 2), o > t.lookahead && (o = t.lookahead); do { if (r = e, l[r + s] === p && l[r + s - 1] === c && l[r] === l[a] && l[++r] === l[a + 1]) { for (a += 2, r++; l[++a] === l[++r] && l[++a] === l[++r] && l[++a] === l[++r] && l[++a] === l[++r] && l[++a] === l[++r] && l[++a] === l[++r] && l[++a] === l[++r] && l[++a] === l[++r] && u > a;); if (n = F - (u - a), a = u - F, n > s) { if (t.match_start = e, s = n, n >= o) break; c = l[a + s - 1], p = l[a + s] } } } while ((e = f[e & h]) > d && 0 != --i); return s <= t.lookahead ? s : t.lookahead } function h(t) { var e, r, n = t.w_size; do { if (r = t.window_size - t.lookahead - t.strstart, t.strstart >= n + (n - Z)) { g.arraySet(t.window, t.window, n, n, 0), t.match_start -= n, t.strstart -= n, t.block_start -= n; var i = e = t.hash_size; do { var a = t.head[--i]; t.head[i] = a >= n ? a - n : 0 } while (--e); i = e = n; do { a = t.prev[--i], t.prev[i] = a >= n ? a - n : 0 } while (--e); r += n } if (0 === t.strm.avail_in) break; i = t.strm, a = t.window; var s = t.strstart + t.lookahead, o = i.avail_in; if (o > r && (o = r), e = 0 === o ? 0 : (i.avail_in -= o, g.arraySet(a, i.input, i.next_in, o, s), 1 === i.state.wrap ? i.adler = v(i.adler, a, o, s) : 2 === i.state.wrap && (i.adler = w(i.adler, a, o, s)), i.next_in += o, i.total_in += o, o), t.lookahead += e, t.lookahead + t.insert >= U) for (r = t.strstart - t.insert, t.ins_h = t.window[r], t.ins_h = (t.ins_h << t.hash_shift ^ t.window[r + 1]) & t.hash_mask; t.insert && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[r + U - 1]) & t.hash_mask, t.prev[r & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = r, r++ , t.insert-- , !(t.lookahead + t.insert < U));); } while (t.lookahead < Z && 0 !== t.strm.avail_in) } function f(t, e) { for (var r, n; ;) { if (t.lookahead < Z) { if (h(t), t.lookahead < Z && e === k) return j; if (0 === t.lookahead) break } if (r = 0, t.lookahead >= U && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + U - 1]) & t.hash_mask, r = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart), 0 !== r && t.strstart - r <= t.w_size - Z && (t.match_length = l(t, r)), t.match_length >= U) if (n = b._tr_tally(t, t.strstart - t.match_start, t.match_length - U), t.lookahead -= t.match_length, t.match_length <= t.max_lazy_match && t.lookahead >= U) { t.match_length--; do { t.strstart++ , t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + U - 1]) & t.hash_mask, r = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart } while (0 != --t.match_length); t.strstart++ } else t.strstart += t.match_length, t.match_length = 0, t.ins_h = t.window[t.strstart], t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + 1]) & t.hash_mask; else n = b._tr_tally(t, 0, t.window[t.strstart]), t.lookahead-- , t.strstart++; if (n && (s(t, !1), 0 === t.strm.avail_out)) return j } return t.insert = t.strstart < U - 1 ? t.strstart : U - 1, e === x ? (s(t, !0), 0 === t.strm.avail_out ? X : K) : t.last_lit && (s(t, !1), 0 === t.strm.avail_out) ? j : H } function u(t, e) { for (var r, n, i; ;) { if (t.lookahead < Z) { if (h(t), t.lookahead < Z && e === k) return j; if (0 === t.lookahead) break } if (r = 0, t.lookahead >= U && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + U - 1]) & t.hash_mask, r = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart), t.prev_length = t.match_length, t.prev_match = t.match_start, t.match_length = U - 1, 0 !== r && t.prev_length < t.max_lazy_match && t.strstart - r <= t.w_size - Z && (t.match_length = l(t, r), 5 >= t.match_length && (t.strategy === C || t.match_length === U && 4096 < t.strstart - t.match_start) && (t.match_length = U - 1)), t.prev_length >= U && t.match_length <= t.prev_length) { i = t.strstart + t.lookahead - U, n = b._tr_tally(t, t.strstart - 1 - t.prev_match, t.prev_length - U), t.lookahead -= t.prev_length - 1, t.prev_length -= 2; do { ++t.strstart <= i && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + U - 1]) & t.hash_mask, r = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart) } while (0 != --t.prev_length); if (t.match_available = 0, t.match_length = U - 1, t.strstart++ , n && (s(t, !1), 0 === t.strm.avail_out)) return j } else if (t.match_available) { if (n = b._tr_tally(t, 0, t.window[t.strstart - 1]), n && s(t, !1), t.strstart++ , t.lookahead-- , 0 === t.strm.avail_out) return j } else t.match_available = 1, t.strstart++ , t.lookahead-- } return t.match_available && (b._tr_tally(t, 0, t.window[t.strstart - 1]), t.match_available = 0), t.insert = t.strstart < U - 1 ? t.strstart : U - 1, e === x ? (s(t, !0), 0 === t.strm.avail_out ? X : K) : t.last_lit && (s(t, !1), 0 === t.strm.avail_out) ? j : H } function c() { this.strm = null, this.status = 0, this.pending_buf = null, this.wrap = this.pending = this.pending_out = this.pending_buf_size = 0, this.gzhead = null, this.gzindex = 0, this.method = B, this.last_flush = -1, this.w_mask = this.w_bits = this.w_size = 0, this.window = null, this.window_size = 0, this.head = this.prev = null, this.nice_match = this.good_match = this.strategy = this.level = this.max_lazy_match = this.max_chain_length = this.prev_length = this.lookahead = this.match_start = this.strstart = this.match_available = this.prev_match = this.match_length = this.block_start = this.hash_shift = this.hash_mask = this.hash_bits = this.hash_size = this.ins_h = 0, this.dyn_ltree = new g.Buf16(2 * D), this.dyn_dtree = new g.Buf16(2 * (2 * T + 1)), this.bl_tree = new g.Buf16(2 * (2 * L + 1)), i(this.dyn_ltree), i(this.dyn_dtree), i(this.bl_tree), this.bl_desc = this.d_desc = this.l_desc = null, this.bl_count = new g.Buf16(N + 1), this.heap = new g.Buf16(2 * R + 1), i(this.heap), this.heap_max = this.heap_len = 0, this.depth = new g.Buf16(2 * R + 1), i(this.depth), this.bi_valid = this.bi_buf = this.insert = this.matches = this.static_len = this.opt_len = this.d_buf = this.last_lit = this.lit_bufsize = this.l_buf = 0 } function p(t) { var e; return t && t.state ? (t.total_in = t.total_out = 0, t.data_type = I, e = t.state, e.pending = 0, e.pending_out = 0, 0 > e.wrap && (e.wrap = -e.wrap), e.status = e.wrap ? P : M, t.adler = 2 === e.wrap ? 0 : 1, e.last_flush = k, b._tr_init(e), z) : n(t, E) } function _(t) { var e = p(t); return e === z && (t = t.state, t.window_size = 2 * t.w_size, i(t.head), t.max_lazy_match = V[t.level].max_lazy, t.good_match = V[t.level].good_length, t.nice_match = V[t.level].nice_length, t.max_chain_length = V[t.level].max_chain, t.strstart = 0, t.block_start = 0, t.lookahead = 0, t.insert = 0, t.match_length = t.prev_length = U - 1, t.match_available = 0, t.ins_h = 0), e } function m(t, e, r, i, a, s) { if (!t) return E; var o = 1; if (e === A && (e = 6), 0 > i ? (o = 0, i = -i) : 15 < i && (o = 2, i -= 16), 1 > a || a > O || r !== B || 8 > i || 15 < i || 0 > e || 9 < e || 0 > s || s > S) return n(t, E); 8 === i && (i = 9); var d = new c; return t.state = d, d.strm = t, d.wrap = o, d.gzhead = null, d.w_bits = i, d.w_size = 1 << d.w_bits, d.w_mask = d.w_size - 1, d.hash_bits = a + 7, d.hash_size = 1 << d.hash_bits, d.hash_mask = d.hash_size - 1, d.hash_shift = ~~((d.hash_bits + U - 1) / U), d.window = new g.Buf8(2 * d.w_size), d.head = new g.Buf16(d.hash_size), d.prev = new g.Buf16(d.w_size), d.lit_bufsize = 1 << a + 6, d.pending_buf_size = 4 * d.lit_bufsize, d.pending_buf = new g.Buf8(d.pending_buf_size), d.d_buf = d.lit_bufsize >> 1, d.l_buf = 3 * d.lit_bufsize, d.level = e, d.strategy = s, d.method = r, _(t) } var g = t("../utils/common"), b = t("./trees"), v = t("./adler32"), w = t("./crc32"), y = t("./messages"), k = 0, x = 4, z = 0, E = -2, A = -1, C = 1, S = 4, I = 2, B = 8, O = 9, R = 286, T = 30, L = 19, D = 2 * R + 1, N = 15, U = 3, F = 258, Z = F + U + 1, P = 42, M = 113, j = 1, H = 2, X = 3, K = 4; t = function (t, e, r, n, i) { this.good_length = t, this.max_lazy = e, this.nice_length = r, this.max_chain = n, this.func = i }; var V = [new t(0, 0, 0, 0, function (t, e) { var r = 65535; for (r > t.pending_buf_size - 5 && (r = t.pending_buf_size - 5); ;) { if (1 >= t.lookahead) { if (h(t), 0 === t.lookahead && e === k) return j; if (0 === t.lookahead) break } t.strstart += t.lookahead, t.lookahead = 0; var n = t.block_start + r; if ((0 === t.strstart || t.strstart >= n) && (t.lookahead = t.strstart - n, t.strstart = n, s(t, !1), 0 === t.strm.avail_out) || t.strstart - t.block_start >= t.w_size - Z && (s(t, !1), 0 === t.strm.avail_out)) return j } return t.insert = 0, e === x ? (s(t, !0), 0 === t.strm.avail_out ? X : K) : (t.strstart > t.block_start && s(t, !1), j) }), new t(4, 4, 8, 4, f), new t(4, 5, 16, 8, f), new t(4, 6, 32, 32, f), new t(4, 4, 16, 16, u), new t(8, 16, 32, 32, u), new t(8, 16, 128, 128, u), new t(8, 32, 128, 256, u), new t(32, 128, 258, 1024, u), new t(32, 258, 258, 4096, u)]; r.deflateInit = function (t, e) { return m(t, e, B, 15, 8, 0) }, r.deflateInit2 = m, r.deflateReset = _, r.deflateResetKeep = p, r.deflateSetHeader = function (t, e) { return t && t.state ? 2 !== t.state.wrap ? E : (t.state.gzhead = e, z) : E }, r.deflate = function (t, e) { var r, l; if (!t || !t.state || 5 < e || 0 > e) return t ? n(t, E) : E; if (l = t.state, !t.output || !t.input && 0 !== t.avail_in || 666 === l.status && e !== x) return n(t, 0 === t.avail_out ? -5 : E); if (l.strm = t, r = l.last_flush, l.last_flush = e, l.status === P) if (2 === l.wrap) t.adler = 0, o(l, 31), o(l, 139), o(l, 8), l.gzhead ? (o(l, (l.gzhead.text ? 1 : 0) + (l.gzhead.hcrc ? 2 : 0) + (l.gzhead.extra ? 4 : 0) + (l.gzhead.name ? 8 : 0) + (l.gzhead.comment ? 16 : 0)), o(l, 255 & l.gzhead.time), o(l, l.gzhead.time >> 8 & 255), o(l, l.gzhead.time >> 16 & 255), o(l, l.gzhead.time >> 24 & 255), o(l, 9 === l.level ? 2 : 2 <= l.strategy || 2 > l.level ? 4 : 0), o(l, 255 & l.gzhead.os), l.gzhead.extra && l.gzhead.extra.length && (o(l, 255 & l.gzhead.extra.length), o(l, l.gzhead.extra.length >> 8 & 255)), l.gzhead.hcrc && (t.adler = w(t.adler, l.pending_buf, l.pending, 0)), l.gzindex = 0, l.status = 69) : (o(l, 0), o(l, 0), o(l, 0), o(l, 0), o(l, 0), o(l, 9 === l.level ? 2 : 2 <= l.strategy || 2 > l.level ? 4 : 0), o(l, 3), l.status = M); else { var f = B + (l.w_bits - 8 << 4) << 8; f |= (2 <= l.strategy || 2 > l.level ? 0 : 6 > l.level ? 1 : 6 === l.level ? 2 : 3) << 6, 0 !== l.strstart && (f |= 32), l.status = M, d(l, f + (31 - f % 31)), 0 !== l.strstart && (d(l, t.adler >>> 16), d(l, 65535 & t.adler)), t.adler = 1 } if (69 === l.status) if (l.gzhead.extra) { for (f = l.pending; l.gzindex < (65535 & l.gzhead.extra.length) && (l.pending !== l.pending_buf_size || (l.gzhead.hcrc && l.pending > f && (t.adler = w(t.adler, l.pending_buf, l.pending - f, f)), a(t), f = l.pending, l.pending !== l.pending_buf_size));)o(l, 255 & l.gzhead.extra[l.gzindex]), l.gzindex++; l.gzhead.hcrc && l.pending > f && (t.adler = w(t.adler, l.pending_buf, l.pending - f, f)), l.gzindex === l.gzhead.extra.length && (l.gzindex = 0, l.status = 73) } else l.status = 73; if (73 === l.status) if (l.gzhead.name) { f = l.pending; do { if (l.pending === l.pending_buf_size && (l.gzhead.hcrc && l.pending > f && (t.adler = w(t.adler, l.pending_buf, l.pending - f, f)), a(t), f = l.pending, l.pending === l.pending_buf_size)) { var u = 1; break } u = l.gzindex < l.gzhead.name.length ? 255 & l.gzhead.name.charCodeAt(l.gzindex++) : 0, o(l, u) } while (0 !== u); l.gzhead.hcrc && l.pending > f && (t.adler = w(t.adler, l.pending_buf, l.pending - f, f)), 0 === u && (l.gzindex = 0, l.status = 91) } else l.status = 91; if (91 === l.status) if (l.gzhead.comment) { f = l.pending; do { if (l.pending === l.pending_buf_size && (l.gzhead.hcrc && l.pending > f && (t.adler = w(t.adler, l.pending_buf, l.pending - f, f)), a(t), f = l.pending, l.pending === l.pending_buf_size)) { u = 1; break } u = l.gzindex < l.gzhead.comment.length ? 255 & l.gzhead.comment.charCodeAt(l.gzindex++) : 0, o(l, u) } while (0 !== u); l.gzhead.hcrc && l.pending > f && (t.adler = w(t.adler, l.pending_buf, l.pending - f, f)), 0 === u && (l.status = 103) } else l.status = 103; if (103 === l.status && (l.gzhead.hcrc ? (l.pending + 2 > l.pending_buf_size && a(t), l.pending + 2 <= l.pending_buf_size && (o(l, 255 & t.adler), o(l, t.adler >> 8 & 255), t.adler = 0, l.status = M)) : l.status = M), 0 !== l.pending) { if (a(t), 0 === t.avail_out) return l.last_flush = -1, z } else if (0 === t.avail_in && (e << 1) - (4 < e ? 9 : 0) <= (r << 1) - (4 < r ? 9 : 0) && e !== x) return n(t, -5); if (666 === l.status && 0 !== t.avail_in) return n(t, -5); if (0 !== t.avail_in || 0 !== l.lookahead || e !== k && 666 !== l.status) { if (2 === l.strategy) t: { for (var c; ;) { if (0 === l.lookahead && (h(l), 0 === l.lookahead)) { if (e === k) { var p = j; break t } break } if (l.match_length = 0, c = b._tr_tally(l, 0, l.window[l.strstart]), l.lookahead-- , l.strstart++ , c && (s(l, !1), 0 === l.strm.avail_out)) { p = j; break t } } l.insert = 0, p = e === x ? (s(l, !0), 0 === l.strm.avail_out ? X : K) : l.last_lit && (s(l, !1), 0 === l.strm.avail_out) ? j : H } else if (3 === l.strategy) t: { var _, m; for (c = l.window; ;) { if (l.lookahead <= F) { if (h(l), l.lookahead <= F && e === k) { p = j; break t } if (0 === l.lookahead) break } if (l.match_length = 0, l.lookahead >= U && 0 < l.strstart && (m = l.strstart - 1, (_ = c[m]) === c[++m] && _ === c[++m] && _ === c[++m])) { for (r = l.strstart + F; _ === c[++m] && _ === c[++m] && _ === c[++m] && _ === c[++m] && _ === c[++m] && _ === c[++m] && _ === c[++m] && _ === c[++m] && r > m;); l.match_length = F - (r - m), l.match_length > l.lookahead && (l.match_length = l.lookahead) } if (l.match_length >= U ? (p = b._tr_tally(l, 1, l.match_length - U), l.lookahead -= l.match_length, l.strstart += l.match_length, l.match_length = 0) : (p = b._tr_tally(l, 0, l.window[l.strstart]), l.lookahead-- , l.strstart++), p && (s(l, !1), 0 === l.strm.avail_out)) { p = j; break t } } l.insert = 0, p = e === x ? (s(l, !0), 0 === l.strm.avail_out ? X : K) : l.last_lit && (s(l, !1), 0 === l.strm.avail_out) ? j : H } else p = V[l.level].func(l, e); if ((p === X || p === K) && (l.status = 666), p === j || p === X) return 0 === t.avail_out && (l.last_flush = -1), z; if (p === H && (1 === e ? b._tr_align(l) : 5 !== e && (b._tr_stored_block(l, 0, 0, !1), 3 === e && (i(l.head), 0 === l.lookahead && (l.strstart = 0, l.block_start = 0, l.insert = 0))), a(t), 0 === t.avail_out)) return l.last_flush = -1, z } return e !== x ? z : 0 >= l.wrap ? 1 : (2 === l.wrap ? (o(l, 255 & t.adler), o(l, t.adler >> 8 & 255), o(l, t.adler >> 16 & 255), o(l, t.adler >> 24 & 255), o(l, 255 & t.total_in), o(l, t.total_in >> 8 & 255), o(l, t.total_in >> 16 & 255), o(l, t.total_in >> 24 & 255)) : (d(l, t.adler >>> 16), d(l, 65535 & t.adler)), a(t), 0 < l.wrap && (l.wrap = -l.wrap), 0 !== l.pending ? z : 1) }, r.deflateEnd = function (t) { var e; return t && t.state ? (e = t.state.status, e !== P && 69 !== e && 73 !== e && 91 !== e && 103 !== e && e !== M && 666 !== e ? n(t, E) : (t.state = null, e === M ? n(t, -3) : z)) : E }, r.deflateInfo = "pako deflate (from Nodeca project)" }, { "../utils/common": 27, "./adler32": 29, "./crc32": 31, "./messages": 37, "./trees": 38 }], 33: [function (t, e) { e.exports = function () { this.os = this.xflags = this.time = this.text = 0, this.extra = null, this.extra_len = 0, this.comment = this.name = "", this.hcrc = 0, this.done = !1 } }, {}], 34: [function (t, e) { e.exports = function (t, e) { var r, n, i, a = t.state, s = t.next_in, o = t.input, d = s + (t.avail_in - 5), l = t.next_out, h = t.output; e = l - (e - t.avail_out); var f = l + (t.avail_out - 257), u = a.dmax, c = a.wsize, p = a.whave, _ = a.wnext, m = a.window, g = a.hold, b = a.bits, v = a.lencode, w = a.distcode, y = (1 << a.lenbits) - 1, k = (1 << a.distbits) - 1; t: do { 15 > b && (g += o[s++] << b, b += 8, g += o[s++] << b, b += 8); var x = v[g & y]; e: for (; ;) { if (r = x >>> 24, g >>>= r, b -= r, 0 === (r = x >>> 16 & 255)) h[l++] = 65535 & x; else { if (!(16 & r)) { if (0 == (64 & r)) { x = v[(65535 & x) + (g & (1 << r) - 1)]; continue e } if (32 & r) { a.mode = 12; break t } t.msg = "invalid literal/length code", a.mode = 30; break t } var z = 65535 & x; (r &= 15) && (r > b && (g += o[s++] << b, b += 8), z += g & (1 << r) - 1, g >>>= r, b -= r), 15 > b && (g += o[s++] << b, b += 8, g += o[s++] << b, b += 8), x = w[g & k]; r: for (; ;) { if (r = x >>> 24, g >>>= r, b -= r, !(16 & (r = x >>> 16 & 255))) { if (0 == (64 & r)) { x = w[(65535 & x) + (g & (1 << r) - 1)]; continue r } t.msg = "invalid distance code", a.mode = 30; break t } if (n = 65535 & x, r &= 15, r > b && (g += o[s++] << b, b += 8, r > b && (g += o[s++] << b, b += 8)), (n += g & (1 << r) - 1) > u) { t.msg = "invalid distance too far back", a.mode = 30; break t } if (g >>>= r, b -= r, r = l - e, n > r) { if ((r = n - r) > p && a.sane) { t.msg = "invalid distance too far back", a.mode = 30; break t } if (x = 0, i = m, 0 === _) { if (x += c - r, z > r) { z -= r; do { h[l++] = m[x++] } while (--r); x = l - n, i = h } } else if (r > _) { if (x += c + _ - r, r -= _, z > r) { z -= r; do { h[l++] = m[x++] } while (--r); if (x = 0, z > _) { r = _, z -= r; do { h[l++] = m[x++] } while (--r); x = l - n, i = h } } } else if (x += _ - r, z > r) { z -= r; do { h[l++] = m[x++] } while (--r); x = l - n, i = h } for (; 2 < z;)h[l++] = i[x++], h[l++] = i[x++], h[l++] = i[x++], z -= 3; z && (h[l++] = i[x++], 1 < z && (h[l++] = i[x++])) } else { x = l - n; do { h[l++] = h[x++], h[l++] = h[x++], h[l++] = h[x++], z -= 3 } while (2 < z); z && (h[l++] = h[x++], 1 < z && (h[l++] = h[x++])) } break } } break } } while (d > s && f > l); z = b >> 3, s -= z, b -= z << 3, t.next_in = s, t.next_out = l, t.avail_in = d > s ? d - s + 5 : 5 - (s - d), t.avail_out = f > l ? f - l + 257 : 257 - (l - f), a.hold = g & (1 << b) - 1, a.bits = b } }, {}], 35: [function (t, e, r) {
      function n(t) { return (t >>> 24 & 255) + (t >>> 8 & 65280) + ((65280 & t) << 8) + ((255 & t) << 24) } function i() { this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.total = this.check = this.dmax = this.flags = 0, this.head = null, this.wnext = this.whave = this.wsize = this.wbits = 0, this.window = null, this.extra = this.offset = this.length = this.bits = this.hold = 0, this.distcode = this.lencode = null, this.have = this.ndist = this.nlen = this.ncode = this.distbits = this.lenbits = 0, this.next = null, this.lens = new f.Buf16(320), this.work = new f.Buf16(288), this.distdyn = this.lendyn = null, this.was = this.back = this.sane = 0 } function a(t) { var e; return t && t.state ? (e = t.state, t.total_in = t.total_out = e.total = 0, t.msg = "", e.wrap && (t.adler = 1 & e.wrap), e.mode = b, e.last = 0, e.havedict = 0, e.dmax = 32768, e.head = null, e.hold = 0, e.bits = 0, e.lencode = e.lendyn = new f.Buf32(v), e.distcode = e.distdyn = new f.Buf32(w), e.sane = 1, e.back = -1, m) : g } function s(t) { var e; return t && t.state ? (e = t.state, e.wsize = 0, e.whave = 0, e.wnext = 0, a(t)) : g } function o(t, e) { var r, n; return t && t.state ? (n = t.state, 0 > e ? (r = 0, e = -e) : (r = 1 + (e >> 4), 48 > e && (e &= 15)), e && (8 > e || 15 < e) ? g : (null !== n.window && n.wbits !== e && (n.window = null), n.wrap = r, n.wbits = e, s(t))) : g } function d(t, e) { var r, n; return t ? (n = new i, t.state = n, n.window = null, r = o(t, e), r !== m && (t.state = null), r) : g } var l, h, f = t("../utils/common"), u = t("./adler32"), c = t("./crc32"), p = t("./inffast"), _ = t("./inftrees"), m = 0, g = -2, b = 1, v = 852, w = 592, y = !0; r.inflateReset = s, r.inflateReset2 = o, r.inflateResetKeep = a, r.inflateInit = function (t) { return d(t, 15) }, r.inflateInit2 = d, r.inflate = function (t, e) {
        var r, i, a, s, o, d, v, w = 0, k = new f.Buf8(4), x = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]; if (!t || !t.state || !t.output || !t.input && 0 !== t.avail_in) return g; var z = t.state; 12 === z.mode && (z.mode = 13); var E = t.next_out, A = t.output, C = t.avail_out, S = t.next_in, I = t.input, B = t.avail_in, O = z.hold, R = z.bits, T = B, L = C, D = m; t: for (; ;)switch (z.mode) {
          case b: if (0 === z.wrap) { z.mode = 13; break } for (; 16 > R;) { if (0 === B) break t; B-- , O += I[S++] << R, R += 8 } if (2 & z.wrap && 35615 === O) { z.check = 0, k[0] = 255 & O, k[1] = O >>> 8 & 255, z.check = c(z.check, k, 2, 0), R = O = 0, z.mode = 2; break } if (z.flags = 0, z.head && (z.head.done = !1), !(1 & z.wrap) || (((255 & O) << 8) + (O >> 8)) % 31) { t.msg = "incorrect header check", z.mode = 30; break } if (8 != (15 & O)) { t.msg = "unknown compression method", z.mode = 30; break } if (O >>>= 4, R -= 4, d = 8 + (15 & O), 0 === z.wbits) z.wbits = d; else if (d > z.wbits) { t.msg = "invalid window size", z.mode = 30; break } z.dmax = 1 << d, t.adler = z.check = 1, z.mode = 512 & O ? 10 : 12, R = O = 0; break; case 2: for (; 16 > R;) { if (0 === B) break t; B-- , O += I[S++] << R, R += 8 } if (z.flags = O, 8 != (255 & z.flags)) { t.msg = "unknown compression method", z.mode = 30; break } if (57344 & z.flags) { t.msg = "unknown header flags set", z.mode = 30; break } z.head && (z.head.text = O >> 8 & 1), 512 & z.flags && (k[0] = 255 & O, k[1] = O >>> 8 & 255, z.check = c(z.check, k, 2, 0)), R = O = 0, z.mode = 3; case 3: for (; 32 > R;) { if (0 === B) break t; B-- , O += I[S++] << R, R += 8 } z.head && (z.head.time = O), 512 & z.flags && (k[0] = 255 & O, k[1] = O >>> 8 & 255, k[2] = O >>> 16 & 255, k[3] = O >>> 24 & 255, z.check = c(z.check, k, 4, 0)), R = O = 0, z.mode = 4; case 4: for (; 16 > R;) { if (0 === B) break t; B-- , O += I[S++] << R, R += 8 } z.head && (z.head.xflags = 255 & O, z.head.os = O >> 8), 512 & z.flags && (k[0] = 255 & O, k[1] = O >>> 8 & 255, z.check = c(z.check, k, 2, 0)), R = O = 0, z.mode = 5; case 5: if (1024 & z.flags) { for (; 16 > R;) { if (0 === B) break t; B-- , O += I[S++] << R, R += 8 } z.length = O, z.head && (z.head.extra_len = O), 512 & z.flags && (k[0] = 255 & O, k[1] = O >>> 8 & 255, z.check = c(z.check, k, 2, 0)), R = O = 0 } else z.head && (z.head.extra = null); z.mode = 6; case 6: if (1024 & z.flags && (r = z.length, r > B && (r = B), r && (z.head && (d = z.head.extra_len - z.length, z.head.extra || (z.head.extra = Array(z.head.extra_len)), f.arraySet(z.head.extra, I, S, r, d)), 512 & z.flags && (z.check = c(z.check, I, r, S)), B -= r, S += r, z.length -= r), z.length)) break t; z.length = 0, z.mode = 7; case 7: if (2048 & z.flags) { if (0 === B) break t; r = 0; do { d = I[S + r++], z.head && d && 65536 > z.length && (z.head.name += String.fromCharCode(d)) } while (d && B > r); if (512 & z.flags && (z.check = c(z.check, I, r, S)), B -= r, S += r, d) break t } else z.head && (z.head.name = null); z.length = 0, z.mode = 8; case 8: if (4096 & z.flags) { if (0 === B) break t; r = 0; do { d = I[S + r++], z.head && d && 65536 > z.length && (z.head.comment += String.fromCharCode(d)) } while (d && B > r); if (512 & z.flags && (z.check = c(z.check, I, r, S)), B -= r, S += r, d) break t } else z.head && (z.head.comment = null); z.mode = 9; case 9: if (512 & z.flags) { for (; 16 > R;) { if (0 === B) break t; B-- , O += I[S++] << R, R += 8 } if (O !== (65535 & z.check)) { t.msg = "header crc mismatch", z.mode = 30; break } R = O = 0 } z.head && (z.head.hcrc = z.flags >> 9 & 1, z.head.done = !0), t.adler = z.check = 0, z.mode = 12; break; case 10: for (; 32 > R;) { if (0 === B) break t; B-- , O += I[S++] << R, R += 8 } t.adler = z.check = n(O), R = O = 0, z.mode = 11; case 11: if (0 === z.havedict) return t.next_out = E, t.avail_out = C, t.next_in = S, t.avail_in = B, z.hold = O, z.bits = R, 2; t.adler = z.check = 1, z.mode = 12; case 12: if (5 === e || 6 === e) break t; case 13: if (z.last) { O >>>= 7 & R, R -= 7 & R, z.mode = 27; break } for (; 3 > R;) { if (0 === B) break t; B-- , O += I[S++] << R, R += 8 } switch (z.last = 1 & O, O >>>= 1, --R, 3 & O) { case 0: z.mode = 14; break; case 1: var N = z; if (y) { for (l = new f.Buf32(512), h = new f.Buf32(32), a = 0; 144 > a;)N.lens[a++] = 8; for (; 256 > a;)N.lens[a++] = 9; for (; 280 > a;)N.lens[a++] = 7; for (; 288 > a;)N.lens[a++] = 8; for (_(1, N.lens, 0, 288, l, 0, N.work, { bits: 9 }), a = 0; 32 > a;)N.lens[a++] = 5; _(2, N.lens, 0, 32, h, 0, N.work, { bits: 5 }), y = !1 } if (N.lencode = l, N.lenbits = 9, N.distcode = h, N.distbits = 5, z.mode = 20, 6 === e) { O >>>= 2, R -= 2; break t } break; case 2: z.mode = 17; break; case 3: t.msg = "invalid block type", z.mode = 30 }O >>>= 2, R -= 2; break; case 14: for (O >>>= 7 & R, R -= 7 & R; 32 > R;) { if (0 === B) break t; B-- , O += I[S++] << R, R += 8 } if ((65535 & O) != (O >>> 16 ^ 65535)) { t.msg = "invalid stored block lengths", z.mode = 30; break } if (z.length = 65535 & O, O = 0, R = 0, z.mode = 15, 6 === e) break t; case 15: z.mode = 16; case 16: if (r = z.length) { if (r > B && (r = B), r > C && (r = C), 0 === r) break t; f.arraySet(A, I, S, r, E), B -= r, S += r, C -= r, E += r, z.length -= r; break } z.mode = 12; break; case 17: for (; 14 > R;) { if (0 === B) break t; B-- , O += I[S++] << R, R += 8 } if (z.nlen = 257 + (31 & O), O >>>= 5, R -= 5, z.ndist = 1 + (31 & O), O >>>= 5, R -= 5, z.ncode = 4 + (15 & O), O >>>= 4, R -= 4, 286 < z.nlen || 30 < z.ndist) { t.msg = "too many length or distance symbols", z.mode = 30; break } z.have = 0, z.mode = 18; case 18: for (; z.have < z.ncode;) { for (; 3 > R;) { if (0 === B) break t; B-- , O += I[S++] << R, R += 8 } z.lens[x[z.have++]] = 7 & O, O >>>= 3, R -= 3 } for (; 19 > z.have;)z.lens[x[z.have++]] = 0; if (z.lencode = z.lendyn, z.lenbits = 7, v = { bits: z.lenbits }, D = _(0, z.lens, 0, 19, z.lencode, 0, z.work, v), z.lenbits = v.bits, D) { t.msg = "invalid code lengths set", z.mode = 30; break } z.have = 0, z.mode = 19; case 19: for (; z.have < z.nlen + z.ndist;) { for (; w = z.lencode[O & (1 << z.lenbits) - 1], s = w >>> 24, N = 65535 & w, !(R >= s);) { if (0 === B) break t; B-- , O += I[S++] << R, R += 8 } if (16 > N) O >>>= s, R -= s, z.lens[z.have++] = N; else { if (16 === N) { for (a = s + 2; a > R;) { if (0 === B) break t; B-- , O += I[S++] << R, R += 8 } if (O >>>= s, R -= s, 0 === z.have) { t.msg = "invalid bit length repeat", z.mode = 30; break } d = z.lens[z.have - 1], r = 3 + (3 & O), O >>>= 2, R -= 2 } else if (17 === N) { for (a = s + 3; a > R;) { if (0 === B) break t; B-- , O += I[S++] << R, R += 8 } O >>>= s, R -= s, d = 0, r = 3 + (7 & O), O >>>= 3, R -= 3 } else { for (a = s + 7; a > R;) { if (0 === B) break t; B-- , O += I[S++] << R, R += 8 } O >>>= s, R -= s, d = 0, r = 11 + (127 & O), O >>>= 7, R -= 7 } if (z.have + r > z.nlen + z.ndist) { t.msg = "invalid bit length repeat", z.mode = 30; break } for (; r--;)z.lens[z.have++] = d } } if (30 === z.mode) break; if (0 === z.lens[256]) { t.msg = "invalid code -- missing end-of-block", z.mode = 30; break } if (z.lenbits = 9, v = { bits: z.lenbits }, D = _(1, z.lens, 0, z.nlen, z.lencode, 0, z.work, v), z.lenbits = v.bits, D) { t.msg = "invalid literal/lengths set", z.mode = 30; break } if (z.distbits = 6, z.distcode = z.distdyn, v = { bits: z.distbits }, D = _(2, z.lens, z.nlen, z.ndist, z.distcode, 0, z.work, v), z.distbits = v.bits, D) { t.msg = "invalid distances set", z.mode = 30; break } if (z.mode = 20, 6 === e) break t; case 20: z.mode = 21; case 21: if (6 <= B && 258 <= C) { t.next_out = E, t.avail_out = C, t.next_in = S, t.avail_in = B, z.hold = O, z.bits = R, p(t, L), E = t.next_out, A = t.output, C = t.avail_out, S = t.next_in, I = t.input, B = t.avail_in, O = z.hold, R = z.bits, 12 === z.mode && (z.back = -1); break } for (z.back = 0; w = z.lencode[O & (1 << z.lenbits) - 1], s = w >>> 24, a = w >>> 16 & 255, N = 65535 & w, !(R >= s);) { if (0 === B) break t; B-- , O += I[S++] << R, R += 8 } if (a && 0 == (240 & a)) { var U = s, F = a; for (o = N; w = z.lencode[o + ((O & (1 << U + F) - 1) >> U)], s = w >>> 24, a = w >>> 16 & 255, N = 65535 & w, !(R >= U + s);) { if (0 === B) break t; B-- , O += I[S++] << R, R += 8 } O >>>= U, R -= U, z.back += U } if (O >>>= s, R -= s, z.back += s, z.length = N, 0 === a) { z.mode = 26; break } if (32 & a) { z.back = -1, z.mode = 12; break } if (64 & a) { t.msg = "invalid literal/length code", z.mode = 30; break } z.extra = 15 & a, z.mode = 22; case 22: if (z.extra) { for (a = z.extra; a > R;) { if (0 === B) break t; B-- , O += I[S++] << R, R += 8 } z.length += O & (1 << z.extra) - 1, O >>>= z.extra, R -= z.extra, z.back += z.extra } z.was = z.length, z.mode = 23; case 23: for (; w = z.distcode[O & (1 << z.distbits) - 1], s = w >>> 24, a = w >>> 16 & 255, N = 65535 & w, !(R >= s);) { if (0 === B) break t; B-- , O += I[S++] << R, R += 8 } if (0 == (240 & a)) { for (U = s, F = a, o = N; w = z.distcode[o + ((O & (1 << U + F) - 1) >> U)], s = w >>> 24, a = w >>> 16 & 255, N = 65535 & w, !(R >= U + s);) { if (0 === B) break t; B-- , O += I[S++] << R, R += 8 } O >>>= U, R -= U, z.back += U } if (O >>>= s, R -= s, z.back += s, 64 & a) { t.msg = "invalid distance code", z.mode = 30; break } z.offset = N, z.extra = 15 & a, z.mode = 24; case 24: if (z.extra) { for (a = z.extra; a > R;) { if (0 === B) break t; B-- , O += I[S++] << R, R += 8 } z.offset += O & (1 << z.extra) - 1, O >>>= z.extra, R -= z.extra, z.back += z.extra } if (z.offset > z.dmax) { t.msg = "invalid distance too far back", z.mode = 30; break } z.mode = 25; case 25: if (0 === C) break t; if (r = L - C, z.offset > r) {
            if ((r = z.offset - r) > z.whave && z.sane) { t.msg = "invalid distance too far back", z.mode = 30; break } r > z.wnext ? (r -= z.wnext,
              i = z.wsize - r) : i = z.wnext - r, r > z.length && (r = z.length), a = z.window
          } else a = A, i = E - z.offset, r = z.length; r > C && (r = C), C -= r, z.length -= r; do { A[E++] = a[i++] } while (--r); 0 === z.length && (z.mode = 21); break; case 26: if (0 === C) break t; A[E++] = z.length, C-- , z.mode = 21; break; case 27: if (z.wrap) { for (; 32 > R;) { if (0 === B) break t; B-- , O |= I[S++] << R, R += 8 } if (L -= C, t.total_out += L, z.total += L, L && (t.adler = z.check = z.flags ? c(z.check, A, L, E - L) : u(z.check, A, L, E - L)), L = C, (z.flags ? O : n(O)) !== z.check) { t.msg = "incorrect data check", z.mode = 30; break } R = O = 0 } z.mode = 28; case 28: if (z.wrap && z.flags) { for (; 32 > R;) { if (0 === B) break t; B-- , O += I[S++] << R, R += 8 } if (O !== (4294967295 & z.total)) { t.msg = "incorrect length check", z.mode = 30; break } R = O = 0 } z.mode = 29; case 29: D = 1; break t; case 30: D = -3; break t; case 31: return -4; default: return g
        }if (t.next_out = E, t.avail_out = C, t.next_in = S, t.avail_in = B, z.hold = O, z.bits = R, S = z.wsize || L !== t.avail_out && 30 > z.mode && (27 > z.mode || 4 !== e)) { S = t.output, E = t.next_out, I = L - t.avail_out; var Z; B = t.state, null === B.window && (B.wsize = 1 << B.wbits, B.wnext = 0, B.whave = 0, B.window = new f.Buf8(B.wsize)), I >= B.wsize ? (f.arraySet(B.window, S, E - B.wsize, B.wsize, 0), B.wnext = 0, B.whave = B.wsize) : (Z = B.wsize - B.wnext, Z > I && (Z = I), f.arraySet(B.window, S, E - I, Z, B.wnext), I -= Z, I ? (f.arraySet(B.window, S, E - I, I, 0), B.wnext = I, B.whave = B.wsize) : (B.wnext += Z, B.wnext === B.wsize && (B.wnext = 0), B.whave < B.wsize && (B.whave += Z))), S = 0 } return S ? (z.mode = 31, -4) : (T -= t.avail_in, L -= t.avail_out, t.total_in += T, t.total_out += L, z.total += L, z.wrap && L && (t.adler = z.check = z.flags ? c(z.check, A, L, t.next_out - L) : u(z.check, A, L, t.next_out - L)), t.data_type = z.bits + (z.last ? 64 : 0) + (12 === z.mode ? 128 : 0) + (20 === z.mode || 15 === z.mode ? 256 : 0), (0 === T && 0 === L || 4 === e) && D === m && (D = -5), D)
      }, r.inflateEnd = function (t) { if (!t || !t.state) return g; var e = t.state; return e.window && (e.window = null), t.state = null, m }, r.inflateGetHeader = function (t, e) { var r; return t && t.state ? (r = t.state, 0 == (2 & r.wrap) ? g : (r.head = e, e.done = !1, m)) : g }, r.inflateInfo = "pako inflate (from Nodeca project)"
    }, { "../utils/common": 27, "./adler32": 29, "./crc32": 31, "./inffast": 34, "./inftrees": 36 }], 36: [function (t, e) { var r = t("../utils/common"), n = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], i = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], a = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], s = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64]; e.exports = function (t, e, o, d, l, h, f, u) { var c, p, _, m, g, b, v, w, y, k, x, z, E = u.bits, A = 0, C = null, S = 0, I = new r.Buf16(16), B = new r.Buf16(16), O = null, R = 0; for (v = 0; 15 >= v; v++)I[v] = 0; for (w = 0; d > w; w++)I[e[o + w]]++; var T = E; for (y = 15; 1 <= y && 0 === I[y]; y--); if (T > y && (T = y), 0 === y) return l[h++] = 20971520, l[h++] = 20971520, u.bits = 1, 0; for (E = 1; y > E && 0 === I[E]; E++); for (E > T && (T = E), v = c = 1; 15 >= v; v++)if (c <<= 1, 0 > (c -= I[v])) return -1; if (0 < c && (0 === t || 1 !== y)) return -1; for (B[1] = 0, v = 1; 15 > v; v++)B[v + 1] = B[v] + I[v]; for (w = 0; d > w; w++)0 !== e[o + w] && (f[B[e[o + w]]++] = w); if (0 === t ? (C = O = f, m = 19) : 1 === t ? (C = n, S -= 257, O = i, R -= 257, m = 256) : (C = a, O = s, m = -1), z = 0, w = 0, v = E, B = h, k = T, x = 0, _ = -1, A = 1 << T, d = A - 1, 1 === t && 852 < A || 2 === t && 592 < A) return 1; for (var L = 0; ;) { L++; var D = v - x; f[w] < m ? (g = 0, b = f[w]) : f[w] > m ? (g = O[R + f[w]], b = C[S + f[w]]) : (g = 96, b = 0), c = 1 << v - x, E = p = 1 << k; do { p -= c, l[B + (z >> x) + p] = D << 24 | g << 16 | b | 0 } while (0 !== p); for (c = 1 << v - 1; z & c;)c >>= 1; if (0 !== c ? (z &= c - 1, z += c) : z = 0, w++ , 0 == --I[v]) { if (v === y) break; v = e[o + f[w]] } if (v > T && (z & d) !== _) { for (0 === x && (x = T), B += E, k = v - x, c = 1 << k; y > k + x && !(0 >= (c -= I[k + x]));)k++ , c <<= 1; if (A += 1 << k, 1 === t && 852 < A || 2 === t && 592 < A) return 1; _ = z & d, l[_] = T << 24 | k << 16 | B - h | 0 } } return 0 !== z && (l[B + z] = v - x << 24 | 4194304), u.bits = T, 0 } }, { "../utils/common": 27 }], 37: [function (t, e) { e.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" } }, {}], 38: [function (t, e, r) { function n(t) { for (var e = t.length; 0 <= --e;)t[e] = 0 } function i(t, e) { t.pending_buf[t.pending++] = 255 & e, t.pending_buf[t.pending++] = e >>> 8 & 255 } function a(t, e, r) { t.bi_valid > I - r ? (t.bi_buf |= e << t.bi_valid & 65535, i(t, t.bi_buf), t.bi_buf = e >> I - t.bi_valid, t.bi_valid += r - I) : (t.bi_buf |= e << t.bi_valid & 65535, t.bi_valid += r) } function s(t, e, r) { a(t, r[2 * e], r[2 * e + 1]) } function o(t, e) { var r = 0; do { r |= 1 & t, t >>>= 1, r <<= 1 } while (0 < --e); return r >>> 1 } function d(t, e, r) { var n, i = Array(S + 1), a = 0; for (n = 1; S >= n; n++)i[n] = a = a + r[n - 1] << 1; for (r = 0; e >= r; r++)0 !== (n = t[2 * r + 1]) && (t[2 * r] = o(i[n]++, n)) } function l(t) { var e; for (e = 0; z > e; e++)t.dyn_ltree[2 * e] = 0; for (e = 0; E > e; e++)t.dyn_dtree[2 * e] = 0; for (e = 0; A > e; e++)t.bl_tree[2 * e] = 0; t.dyn_ltree[2 * B] = 1, t.opt_len = t.static_len = 0, t.last_lit = t.matches = 0 } function h(t) { 8 < t.bi_valid ? i(t, t.bi_buf) : 0 < t.bi_valid && (t.pending_buf[t.pending++] = t.bi_buf), t.bi_buf = 0, t.bi_valid = 0 } function f(t, e, r, n) { var i = 2 * e, a = 2 * r; return t[i] < t[a] || t[i] === t[a] && n[e] <= n[r] } function u(t, e, r) { for (var n = t.heap[r], i = r << 1; i <= t.heap_len && (i < t.heap_len && f(e, t.heap[i + 1], t.heap[i], t.depth) && i++ , !f(e, n, t.heap[i], t.depth));)t.heap[r] = t.heap[i], r = i, i <<= 1; t.heap[r] = n } function c(t, e, r) { var n, i, o = 0; if (0 !== t.last_lit) do { var d = t.pending_buf[t.d_buf + 2 * o] << 8 | t.pending_buf[t.d_buf + 2 * o + 1], l = t.pending_buf[t.l_buf + o]; o++ , 0 === d ? s(t, l, e) : (n = M[l], s(t, n + x + 1, e), i = L[n], 0 !== i && (l -= j[n], a(t, l, i)), d-- , n = 256 > d ? P[d] : P[256 + (d >>> 7)], s(t, n, r), 0 !== (i = D[n]) && (d -= H[n], a(t, d, i))) } while (o < t.last_lit); s(t, B, e) } function p(t, e) { var r, n = e.dyn_tree, i = e.stat_desc.static_tree, a = e.stat_desc.has_stree, s = e.stat_desc.elems, o = -1; for (t.heap_len = 0, t.heap_max = C, r = 0; s > r; r++)0 !== n[2 * r] ? (t.heap[++t.heap_len] = o = r, t.depth[r] = 0) : n[2 * r + 1] = 0; for (; 2 > t.heap_len;) { var l = t.heap[++t.heap_len] = 2 > o ? ++o : 0; n[2 * l] = 1, t.depth[l] = 0, t.opt_len-- , a && (t.static_len -= i[2 * l + 1]) } for (e.max_code = o, r = t.heap_len >> 1; 1 <= r; r--)u(t, n, r); l = s; do { r = t.heap[1], t.heap[1] = t.heap[t.heap_len--], u(t, n, 1), i = t.heap[1], t.heap[--t.heap_max] = r, t.heap[--t.heap_max] = i, n[2 * l] = n[2 * r] + n[2 * i], t.depth[l] = (t.depth[r] >= t.depth[i] ? t.depth[r] : t.depth[i]) + 1, n[2 * r + 1] = n[2 * i + 1] = l, t.heap[1] = l++ , u(t, n, 1) } while (2 <= t.heap_len); t.heap[--t.heap_max] = t.heap[1]; var h, f; r = e.dyn_tree, l = e.max_code, s = e.stat_desc.static_tree; var c = e.stat_desc.has_stree, p = e.stat_desc.extra_bits, _ = e.stat_desc.extra_base, m = e.stat_desc.max_length, g = 0; for (a = 0; S >= a; a++)t.bl_count[a] = 0; for (r[2 * t.heap[t.heap_max] + 1] = 0, e = t.heap_max + 1; C > e; e++)i = t.heap[e], a = r[2 * r[2 * i + 1] + 1] + 1, a > m && (a = m, g++), r[2 * i + 1] = a, i > l || (t.bl_count[a]++ , h = 0, i >= _ && (h = p[i - _]), f = r[2 * i], t.opt_len += f * (a + h), c && (t.static_len += f * (s[2 * i + 1] + h))); if (0 !== g) { do { for (a = m - 1; 0 === t.bl_count[a];)a--; t.bl_count[a]-- , t.bl_count[a + 1] += 2, t.bl_count[m]-- , g -= 2 } while (0 < g); for (a = m; 0 !== a; a--)for (i = t.bl_count[a]; 0 !== i;)(h = t.heap[--e]) > l || (r[2 * h + 1] !== a && (t.opt_len += (a - r[2 * h + 1]) * r[2 * h], r[2 * h + 1] = a), i--) } d(n, o, t.bl_count) } function _(t, e, r) { var n, i = -1, a = e[1], s = 0, o = 7, d = 4; for (0 === a && (o = 138, d = 3), e[2 * (r + 1) + 1] = 65535, n = 0; r >= n; n++) { var l = a; a = e[2 * (n + 1) + 1], ++s < o && l === a || (d > s ? t.bl_tree[2 * l] += s : 0 !== l ? (l !== i && t.bl_tree[2 * l]++ , t.bl_tree[2 * O]++) : 10 >= s ? t.bl_tree[2 * R]++ : t.bl_tree[2 * T]++ , s = 0, i = l, 0 === a ? (o = 138, d = 3) : l === a ? (o = 6, d = 3) : (o = 7, d = 4)) } } function m(t, e, r) { var n, i, o = -1, d = e[1], l = 0, h = 7, f = 4; for (0 === d && (h = 138, f = 3), n = 0; r >= n; n++)if (i = d, d = e[2 * (n + 1) + 1], !(++l < h && i === d)) { if (f > l) do { s(t, i, t.bl_tree) } while (0 != --l); else 0 !== i ? (i !== o && (s(t, i, t.bl_tree), l--), s(t, O, t.bl_tree), a(t, l - 3, 2)) : 10 >= l ? (s(t, R, t.bl_tree), a(t, l - 3, 3)) : (s(t, T, t.bl_tree), a(t, l - 11, 7)); l = 0, o = i, 0 === d ? (h = 138, f = 3) : i === d ? (h = 6, f = 3) : (h = 7, f = 4) } } function g(t) { var e, r = 4093624447; for (e = 0; 31 >= e; e++ , r >>>= 1)if (1 & r && 0 !== t.dyn_ltree[2 * e]) return w; if (0 !== t.dyn_ltree[18] || 0 !== t.dyn_ltree[20] || 0 !== t.dyn_ltree[26]) return y; for (e = 32; x > e; e++)if (0 !== t.dyn_ltree[2 * e]) return y; return w } function b(t, e, r, n) { a(t, (k << 1) + (n ? 1 : 0), 3), h(t), i(t, r), i(t, ~r), v.arraySet(t.pending_buf, t.window, e, r, t.pending), t.pending += r } var v = t("../utils/common"), w = 0, y = 1, k = 0, x = 256, z = x + 1 + 29, E = 30, A = 19, C = 2 * z + 1, S = 15, I = 16, B = 256, O = 16, R = 17, T = 18, L = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], D = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], N = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], U = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], F = Array(2 * (z + 2)); n(F); var Z = Array(2 * E); n(Z); var P = Array(512); n(P); var M = Array(256); n(M); var j = Array(29); n(j); var H = Array(E); n(H); var X, K, V, Y = function (t, e, r, n, i) { this.static_tree = t, this.extra_bits = e, this.extra_base = r, this.elems = n, this.max_length = i, this.has_stree = t && t.length }, W = function (t, e) { this.dyn_tree = t, this.max_code = 0, this.stat_desc = e }, q = !1; r._tr_init = function (t) { if (!q) { var e, r, n, i = Array(S + 1); for (n = r = 0; 28 > n; n++)for (j[n] = r, e = 0; e < 1 << L[n]; e++)M[r++] = n; for (M[r - 1] = n, n = r = 0; 16 > n; n++)for (H[n] = r, e = 0; e < 1 << D[n]; e++)P[r++] = n; for (r >>= 7; E > n; n++)for (H[n] = r << 7, e = 0; e < 1 << D[n] - 7; e++)P[256 + r++] = n; for (e = 0; S >= e; e++)i[e] = 0; for (e = 0; 143 >= e;)F[2 * e + 1] = 8, e++ , i[8]++; for (; 255 >= e;)F[2 * e + 1] = 9, e++ , i[9]++; for (; 279 >= e;)F[2 * e + 1] = 7, e++ , i[7]++; for (; 287 >= e;)F[2 * e + 1] = 8, e++ , i[8]++; for (d(F, z + 1, i), e = 0; E > e; e++)Z[2 * e + 1] = 5, Z[2 * e] = o(e, 5); X = new Y(F, L, x + 1, z, S), K = new Y(Z, D, 0, E, S), V = new Y([], N, 0, A, 7), q = !0 } t.l_desc = new W(t.dyn_ltree, X), t.d_desc = new W(t.dyn_dtree, K), t.bl_desc = new W(t.bl_tree, V), t.bi_buf = 0, t.bi_valid = 0, l(t) }, r._tr_stored_block = b, r._tr_flush_block = function (t, e, r, n) { var i = 0; if (0 < t.level) { for (2 === t.strm.data_type && (t.strm.data_type = g(t)), p(t, t.l_desc), p(t, t.d_desc), _(t, t.dyn_ltree, t.l_desc.max_code), _(t, t.dyn_dtree, t.d_desc.max_code), p(t, t.bl_desc), i = A - 1; 3 <= i && 0 === t.bl_tree[2 * U[i] + 1]; i--); t.opt_len += 3 * (i + 1) + 14, i = i; var s = t.opt_len + 3 + 7 >>> 3, o = t.static_len + 3 + 7 >>> 3; s >= o && (s = o) } else s = o = r + 5; if (s >= r + 4 && -1 !== e) b(t, e, r, n); else if (4 === t.strategy || o === s) a(t, 2 + (n ? 1 : 0), 3), c(t, F, Z); else { for (a(t, 4 + (n ? 1 : 0), 3), e = t.l_desc.max_code + 1, r = t.d_desc.max_code + 1, i += 1, a(t, e - 257, 5), a(t, r - 1, 5), a(t, i - 4, 4), s = 0; i > s; s++)a(t, t.bl_tree[2 * U[s] + 1], 3); m(t, t.dyn_ltree, e - 1), m(t, t.dyn_dtree, r - 1), c(t, t.dyn_ltree, t.dyn_dtree) } l(t), n && h(t) }, r._tr_tally = function (t, e, r) { return t.pending_buf[t.d_buf + 2 * t.last_lit] = e >>> 8 & 255, t.pending_buf[t.d_buf + 2 * t.last_lit + 1] = 255 & e, t.pending_buf[t.l_buf + t.last_lit] = 255 & r, t.last_lit++ , 0 === e ? t.dyn_ltree[2 * r]++ : (t.matches++ , e-- , t.dyn_ltree[2 * (M[r] + x + 1)]++ , t.dyn_dtree[2 * (256 > e ? P[e] : P[256 + (e >>> 7)])]++), t.last_lit === t.lit_bufsize - 1 }, r._tr_align = function (t) { a(t, 2, 3), s(t, B, F), 16 === t.bi_valid ? (i(t, t.bi_buf), t.bi_buf = 0, t.bi_valid = 0) : 8 <= t.bi_valid && (t.pending_buf[t.pending++] = 255 & t.bi_buf, t.bi_buf >>= 8, t.bi_valid -= 8) } }, { "../utils/common": 27 }], 39: [function (t, e) { e.exports = function () { this.input = null, this.total_in = this.avail_in = this.next_in = 0, this.output = null, this.total_out = this.avail_out = this.next_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0 } }, {}]
  }, {}, [9])(9)
}()
}(); var saveAs = saveAs || "undefined" != typeof navigator && navigator.msSaveOrOpenBlob && navigator.msSaveOrOpenBlob.bind(navigator) || function (t) { if ("undefined" == typeof navigator || !/MSIE [1-9]\./.test(navigator.userAgent)) { var e = t.document, r = t.URL || t.webkitURL || t, n = e && e.createElement("a") || {}, i = !t.externalHost && "download" in n, a = t.webkitRequestFileSystem, s = t.requestFileSystem || a || t.mozRequestFileSystem, o = function (e) { (t.setImmediate || t.setTimeout)(function () { throw e }, 0) }, d = 0, l = [], h = function () { for (var t = l.length; t--;) { var e = l[t]; "string" == typeof e ? r.revokeObjectURL(e) : e.remove() } l.length = 0 }, f = function (t, e, r) { e = [].concat(e); for (var n = e.length; n--;) { var i = t["on" + e[n]]; if ("function" == typeof i) try { i.call(t, r || t) } catch (t) { o(t) } } }, u = function (r, o) { var h = this, u = r.type, c = !1, p = function () { var e = (t.URL || t.webkitURL || t).createObjectURL(r); return l.push(e), e }, _ = function () { f(h, ["writestart", "progress", "write", "writeend"]) }, m = function () { !c && v || (v = p()), y ? y.location.href = v : window.open(v, "_blank"), h.readyState = h.DONE, _() }, g = function (t) { return function () { if (h.readyState !== h.DONE) return t.apply(this, arguments) } }, b = { create: !0, exclusive: !1 }; if (h.readyState = h.INIT, o || (o = "download"), i) { var v = p(); e = t.document, n = e.createElement("a"), n.href = v, n.download = o, u = e.createEvent("MouseEvents"), u.initMouseEvent("click", !0, !1, t, 0, 0, 0, 0, 0, !1, !1, !1, !1, 0, null), n.dispatchEvent(u), h.readyState = h.DONE, _() } else { if (t.chrome && u && "application/octet-stream" !== u) { var w = r.slice || r.webkitSlice; r = w.call(r, 0, r.size, "application/octet-stream"), c = !0 } if (a && "download" !== o && (o += ".download"), "application/octet-stream" === u || a) var y = t; s ? (d += r.size, s(t.TEMPORARY, d, g(function (t) { t.root.getDirectory("saved", b, g(function (t) { var e = function () { t.getFile(o, b, g(function (t) { t.createWriter(g(function (e) { e.onwriteend = function (e) { y.location.href = t.toURL(), l.push(t), h.readyState = h.DONE, f(h, "writeend", e) }, e.onerror = function () { var t = e.error; t.code !== t.ABORT_ERR && m() }, ["writestart", "progress", "write", "abort"].forEach(function (t) { e["on" + t] = h["on" + t] }), e.write(r), h.abort = function () { e.abort(), h.readyState = h.DONE }, h.readyState = h.WRITING }), m) }), m) }; t.getFile(o, { create: !1 }, g(function (t) { t.remove(), e() }), g(function (t) { t.code === t.NOT_FOUND_ERR ? e() : m() })) }), m) }), m)) : m() } }, c = u.prototype, p = function (t, e) { return new u(t, e) }; return c.abort = function () { this.readyState = this.DONE, f(this, "abort") }, c.readyState = c.INIT = 0, c.WRITING = 1, c.DONE = 2, c.error = c.onwritestart = c.onprogress = c.onwrite = c.onabort = c.onerror = c.onwriteend = null, t.addEventListener && t.addEventListener("unload", h, !1), p.unload = function () { h(), t.removeEventListener("unload", h, !1) }, p } }("undefined" != typeof self && self || "undefined" != typeof window && window || (void 0).content); "undefined" != typeof module && (module.exports = saveAs);